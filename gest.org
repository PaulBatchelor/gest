#+TITLE:Gest
* Overview
Gest is a sequencer for gesture.

Gest lies somewhere between a classical step sequencer and
an automation curve generator. The goal of Gest is to be a
better LFO.

To understand how Gest works, a few terms will be described.

Gest synthesizes =Gestures=: audio-rate control signals
intended to be mapped to parameters of other unit
generators in a modular synthesis environment. The overall
goal of Gest is to be able to use it as a way to add more
layers of nuance to computer-performed music, in
particular, lyrical music.

Similar to a step sequencer, Gest is clocked by an exernal
signal, known as a =conductor= signal. This signal is
expected to be a =phasor= signal, a periodic rising ramp
signal going from 0 to 1. Once instantiated with a
conductor signal, Gest can then be programmed to perform
Gestures.

A phasor is a continuous timing source. Not only does it
mark out pacing, but also position within a beat. Every
full ramp from 0 to 1 is a period, referred to as a =beat=
of time.

Gestures are created in sequences of chunks. A single chunk
is known as a =phrase=. A phrase takes up duration measured
in beats from the conductor signal. The phrase analyzes the
conductor, and resynthesizes a new slower signal: a single
ramp going from 0 to 1 spannign the whole duration of the
phrase. This signal is called a =monoramp=. The monoramp
acts a blank canvas to make rhythms with. A monoramp can be
equally divided up into an arbitray number of smaller
ramps, known as a =polyramp=. Contiguous ramps in a
polyramp can be fused backtogether in monoramps, and then
more polyramps can be made from those. This builds a tree
hierarchy of ramps with various subdivisions, known as a
=ramp tree=.

The end leaves of the Ramp Tree are capped with what is
known as a =target=. A target is a scalar value. Using the
ramps from the Ramp Tree, consecutive targets are
interpolated together to generate a contiguous line
segment. The way segments travel from target A to B is
known as a =behavior=. Behaviors can be any number of
things, including linear, exponential, or step.
* Tangled Files
=gest.c= and =gest.h=.

Defining =GEST_PRIVATE= will expose the core gest struct.

#+NAME: gest.h
#+BEGIN_SRC c :tangle gest.h
#ifndef GEST_H
#define GEST_H

#ifndef SKFLT
#define SKFLT float
#endif

<<typedefs>>

#ifdef GEST_PRIVATE
<<structs>>
#endif

<<funcdefs>>
#endif
#+END_SRC

#+NAME: gest.c
#+BEGIN_SRC c :tangle gest.c
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#define GEST_PRIVATE
#include "gest.h"
<<enums>>
<<static_funcdefs>>
<<funcs>>
#+END_SRC
* Core Struct
** Struct Declaration(s)
All data for instance of gest is managed in a struct
called =gest_d=. It is initialized with =gest_init=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_d gest_d;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
<<struct_gest_target>>
<<struct_ramptree>>
<<struct_phrase>>
<<struct_collection>>
<<gest_state>>
struct gest_d {
    <<gest_d>>
};
#+END_SRC
** Initialization
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_init(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_init(gest_d *g)
{
    <<init>>
}
#+END_SRC
** Cleanup
Fully clean up things with =gest_cleanup=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_cleanup(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_cleanup(gest_d *g)
{
    <<cleanup>>
}
#+END_SRC
** Sizeof
=gest_sizeof= is used for opaque functions.

#+NAME: funcdefs
#+BEGIN_SRC c
size_t gest_sizeof(void);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
size_t gest_sizeof(void)
{
    return sizeof(gest_d);
}
#+END_SRC
* Components
** Conductor Analysis Components
#+NAME: gest_d
#+BEGIN_SRC c
SKFLT last;
SKFLT last_inc;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->last = 0;
g->last_inc = 0;
#+END_SRC

When the previous sample is larger
than the current sample, it is registered as a reset, and
the reset flag is set.
** Phase
#+NAME: gest_d
#+BEGIN_SRC c
SKFLT phs;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->phs = -1;
#+END_SRC
** Top/Selected Target and Cached Values
This is called =curtarget=.

The top target from the first phrase is stored
in a variable called =toptarget=. This is used
so the last target of the last phrase can smoothly
loop back to the top.

#+NAME: gest_d
#+BEGIN_SRC c
gest_target *curtarget;
gest_target *toptarget;
gest_target *nxttarget;
int targetondeck;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->curtarget = NULL;
g->toptarget = NULL;
g->nxttarget = NULL;
g->targetondeck = 0;
#+END_SRC

Value for the current and next targets are cached
for faster accessibility.

#+NAME: gest_d
#+BEGIN_SRC c
SKFLT curval;
SKFLT nxtval;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->curval = 0;
g->nxtval = 0;
#+END_SRC

Update the current target with =set_curtarget=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void set_curtarget(gest_d *g, gest_target *target);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void set_curtarget(gest_d *g, gest_target *target)
{
    g->curtarget = target;
    g->curval = target->value;
    do_actions(g, target);
}
#+END_SRC


#+NAME: funcdefs
#+BEGIN_SRC c
gest_target * gest_curtarget(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
gest_target * gest_curtarget(gest_d *g)
{
    return g->curtarget;
}
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
gest_target * gest_nxttarget(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
gest_target * gest_nxttarget(gest_d *g)
{
    return g->nxttarget;
}
#+END_SRC
** Stack
Tree nodes create a new layer every time it descends into
children nodes. This is managed with a stack containing the
parent node and current state. When a node begins, it
pushes itself onto the stack, and pops itself off when it
ends.
** Modifier
The modifier is a value which mainpulates the increment
value calculated from the analyzing the conductor signal.

It is represented as a rational value with a numerator and
denominator, represented as integers.

#+NAME: gest_d
#+BEGIN_SRC c
int num;
int den;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->num = 1;
g->den = 1;
#+END_SRC

Monoramps manipulate
the numerator, increasing the increment value by a factor
and slowing it down. Polyramps manpulate the denominator,
decreasing the increment amount and speeding it up.
** Top/Selected Phrases
Gestures are created in units of phrases, so a few
variable references are stored here.

For starters, the starting phrase is stored in a variable
called =phrase_top=. It is expected that the gesture will
iterate in a (mostly) linear fashion as a linked list.

When populating and computing gest, the currently
selected phrase is stored in a variable called
=phrase_selected=.

#+NAME: gest_d
#+BEGIN_SRC c
gest_phrase *phrase_top;
gest_phrase *phrase_selected;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->phrase_top = NULL;
g->phrase_selected = NULL;
#+END_SRC
** Collection
A local instance of a =gest_collection=, used to allocate
components needed to make gestures.

#+NAME: gest_d
#+BEGIN_SRC c
gest_collection col;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
collection_init(&g->col);
#+END_SRC

#+NAME: cleanup
#+BEGIN_SRC c
collection_cleanup(&g->col);
#+END_SRC
** Selected Ramp Tree Node
A copy of the currently selected ramp tree node
is stored in a variable called =curnode=.

#+NAME: gest_d
#+BEGIN_SRC c
gest_node *curnode;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->curnode = NULL;
#+END_SRC

select it with =set_curnode=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void set_curnode(gest_d *g, gest_node *node);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void set_curnode(gest_d *g, gest_node *node)
{
    g->curnode = node;
}
#+END_SRC

The next node is also stored as well. Will be needed moving
forward, in order for things like metatargets to work.

#+NAME: gest_d
#+BEGIN_SRC c
gest_node *nxtnode;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->nxtnode = NULL;
#+END_SRC
** Node Position
Needed for debugging.

#+NAME: gest_d
#+BEGIN_SRC c
int nodepos;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->nodepos = 0;
#+END_SRC
** Global Temporal Inertia and Mass
The global inertia and mass amounts used for
temporal weight.

Targets in Gest can manipulate the external conductor
signal, causing temporal fluctuations. Tempo can be
slowed down or sped up by changing the mass. The
rate at which the changes happen is measured with
inertia.

#+NAME: gest_d
#+BEGIN_SRC c
SKFLT inertia;
SKFLT mass;
#+END_SRC

By default, the mass is set to be regular (0) with
instantaneous inertia (0).

#+NAME: init
#+BEGIN_SRC c
g->inertia = 0;
g->mass = 0;
#+END_SRC

Getters are =gest_mass_get= and =gest_inertia_get=.

#+NAME: funcdefs
#+BEGIN_SRC c
SKFLT gest_mass_get(gest_d *g);
SKFLT gest_inertia_get(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
SKFLT gest_mass_get(gest_d *g)
{
    return g->mass;
}

SKFLT gest_inertia_get(gest_d *g)
{
    return g->inertia;
}
#+END_SRC
** Position In Time
Used for clock drift compensation.
Measured in beats, and with an accumulator.

#+NAME: gest_d
#+BEGIN_SRC c
int beat;
SKFLT t;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->beat = 0;
g->t = 0;
#+END_SRC
** Please Wait Flag
#+NAME: gest_d
#+BEGIN_SRC c
int please_wait;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->please_wait = 0;
#+END_SRC
** Correction
#+NAME: gest_d
#+BEGIN_SRC c
SKFLT correction;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->correction = 1.0;
#+END_SRC
** User Data
#+NAME: gest_d
#+BEGIN_SRC c
void *ud;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->ud = NULL;
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_data_set(gest_d *g, void *ud);
void * gest_data_get(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_data_set(gest_d *g, void *ud)
{
    g->ud = ud;
}

void * gest_data_get(gest_d *g)
{
    return g->ud;
}
#+END_SRC
** Previous Output Value
The =prevout= variable caches the output of the
previously computed sample. This is useful for
situations when gest gets paused mid-gesture.

#+NAME: gest_d
#+BEGIN_SRC c
SKFLT prevout;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->prevout = 0;
#+END_SRC
** next target state
The variable =nxtstate= stores the state information
needed for the next node.

#+NAME: gest_d
#+BEGIN_SRC c
gest_state nxtstate;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
init_state(&g->nxtstate);
#+END_SRC

Metatargets change things up. Before metatargets,
it used to be that targets were things that wouldn't
change, and this made logic and flow very simpler.
Metatargets can change their targets. Because of this,
there is a need to introduce cached states.

Basically, when the next target is acquired, it takes
a snapshot of that state, which can then be applied
without any traversal or searching.

State is represetned by the struct =gest_state=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_state gest_state;
#+END_SRC

State includes the target, the node belonging to
that target, the modifier (representation as rational
value with numerator/denominator integers), and the phrase.

#+NAME: gest_state
#+BEGIN_SRC c
struct gest_state {
    gest_target *target;
    gest_node *node;
    gest_phrase *phrase;
    gest_behavior *behavior;
    int num;
    int den;
    int please_wait;
};
#+END_SRC

Initialize state with =init_state=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void init_state(gest_state *s);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void init_state(gest_state *s)
{
    s->num = 1;
    s->den = 1;
    s->phrase = NULL;
    s->target = NULL;
    s->node = NULL;
    s->behavior = NULL;
    s->please_wait = 0;
}
#+END_SRC
* Core Commands
Some core commands for programming gestures.
** Begin
Begin: begins a phrase. Takes in duration (in beats) as an
argument.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_begin(gest_d *g, int beats, int div);
#+END_SRC

The begin command creates and initializes a new phrase,
which then gets appended to the last phrase.

The first phrase to get created becomes the beginning
phrase in gest.

#+NAME: funcs
#+BEGIN_SRC c
void gest_begin(gest_d *g, int beats, int div)
{
    gest_phrase *phrase;

    phrase = gest_alloc(g, sizeof(gest_phrase));
    phrase_init(g, phrase, beats, div);

    if (g->phrase_top == NULL) {
        g->phrase_top = phrase;
    }

    <<append_metaphrase>>

    if (g->phrase_selected != NULL) {
        g->phrase_selected->next = phrase;
    }

    g->phrase_selected = phrase;

    /* TODO make this a targetondeck flag */
    set_curnode(g, g->phrase_selected->top);

}
#+END_SRC
** End
End: closes out the phrase. If the phrase isn't fully
completed a non-zero value is returned.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_end(gest_d *g);
#+END_SRC

Error checking is done by examining the top-level polyramp
in the currently selected phrase. A completed phrase will
have every child node capped with a target.

#+NAME: funcs
#+BEGIN_SRC c
int gest_end(gest_d *g)
{
    int count;
    gest_node *top;

    top = g->phrase_selected->top;

    count = node_count(top, NULL);

    if (count != top->modifier) return 1;

    <<metaphrase_next_position>>
    return 0;
}
#+END_SRC
** Polyramp
Polyramp: Takes the current ramp, and divides it up into N
beats.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_polyramp(gest_d *g, int div);
#+END_SRC

When a new polyramp node is made, it's node becomes
the actively selected node to be populated. If something
goes wrong, an non-zero error value is returned/

#+NAME: funcs
#+BEGIN_SRC c
int gest_polyramp(gest_d *g, int div)
{
    gest_node *n;

    n = mkpolyramp(g, g->curnode, div);

    if (n == NULL) {
        return 1;
    }

    set_curnode(g, n);

    return 0;
}
#+END_SRC
** Monoramp
Monoramp: Produces a monoramp that takes up N beats.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_monoramp(gest_d *g, int nbeats);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_monoramp(gest_d *g, int nbeats)
{
    gest_node *n;

    n = mkmonoramp(g, g->curnode, nbeats);

    if (n == NULL) {
        return 1;
    }

    set_curnode(g, n);

    return 0;
}
#+END_SRC
** Addtarget
Target: Caps the current ramp with a scalar target, as a
floating point value. uses linear behavior by default.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_addtarget(gest_d *g, SKFLT val);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_addtarget(gest_d *g, SKFLT val)
{
    gest_target *t;

    t = mktarget(g);

    if (t == NULL) {
        return 1;
    }

    if (g->toptarget == NULL) {
        g->toptarget = t;
    }

    if (g->curtarget != NULL) {
        g->curtarget->next = t;
    }

    g->curtarget = t;
    t->value = val;
    gest_behavior_linear(g);

    return 0;
}
#+END_SRC
** Finish
The finish command =gest_finish= completes population
and initializes gest to start at the top.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_finish(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_finish(gest_d *g)
{
    gest_node *top;
    gest_target *target;

    g->den = 1;
    g->num = 1;

    g->phrase_selected = g->phrase_top;

    top = dive_to_target(g, g->phrase_top->top);

    set_curnode(g, top);
    target = node_target(g, top);
    target->curbehavior = target_behavior(g, target);
    set_curtarget(g, target);

    init_state(&g->nxtstate);
    find_next_node(g, g->curnode, &g->nxtstate);
    g->nxttarget = g->nxtstate.target;

    if (g->nxttarget != NULL) {
        g->nxtval = g->nxttarget->value;
    } else {
        g->nxtval = g->curval;
    }
}
#+END_SRC
** Loopit
The command =gest_loopit= will loop the current phrase back
to the beginning phrase.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_loopit(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_loopit(gest_d *g)
{
    g->curtarget->next = g->toptarget;
    g->phrase_selected->next = g->phrase_top;
    <<metaphrase_loopit>>
}
#+END_SRC
* Meta Commands and Actions
Commands related to meta-things. Also, placing
things related to actions (such as scalars) here,
as there is no other place to put them, and not
enough of them to make a new category.
** Addmetatarget
The function =gest_addmetatarget= will create a new
metatarget with a size of =sz= metatargets.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_addmetatarget(gest_d *g, int sz);
#+END_SRC

This function will implicitely create a new target
using =gest_addtarget=, then configure this
target to be a metatarget.

After it is created, the metatarget gets pushed onto the
metatarget stack contained in the gest data.

#+NAME: funcs
#+BEGIN_SRC c
int gest_addmetatarget(gest_d *g, int sz)
{
    int rc;
    gest_target *t;
    gest_metatarget *mt;

    if (g->mtpos >= GEST_MTSTACK_SIZE) return 2;

    rc = gest_addtarget(g, -1);

    if (rc) return rc;

    t = g->curtarget;

    mt = metatarget_alloc(g, sz);

    t->get = get_seq;
    t->meta = mt;
    mt->parent = t;

    /* push to stack */
    g->mtstack[g->mtpos++] = mt;
    return 0;
}
#+END_SRC
** Addmetabehavior
Adds a metabehavior of with =sz= behaviors.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_addmetabehavior(gest_d *g, int sz);
#+END_SRC

By default, adding a metabehavior means taking
the behavior in the currently selected target and
converting it into a metabehavior. A nested metabehavior
will already have the root behavior converted
into a metabehavior at this point. If a metabehavior
has been found, it will create a metabehavior on
the next available behavior in the parent metabehavior.

#+NAME: funcs
#+BEGIN_SRC c
int gest_addmetabehavior(gest_d *g, int sz)
{
    gest_target *t;
    gest_metabehavior *mb;
    gest_behavior *b;

    if (g->mbpos >= GEST_MBSTACK_SIZE) return 2;

    t = g->curtarget;

    b = &t->behavior;

    if (b->meta != NULL) {
        /* empty stack, shouldn't happen normally */
        if (g->mbpos <= 0) return 3;

        mb = b->meta;
        b = &mb->behaviors[mb->pos++];

        if (mb->pos >= mb->size) {
            g->mbstack[g->mbpos - 1] = NULL;
            g->mbpos--; /* don't be clever */
        }
    }

    mb = metabehavior_alloc(g, sz);

    b->get = behave_seq;
    b->meta = mb;
    mb->parent = b;

    /* push to stack */
    g->mbstack[g->mbpos++] = mb;
    return 0;
}
#+END_SRC
** Addmetanode
#+NAME: funcdefs
#+BEGIN_SRC c
int gest_addmetanode(gest_d *g, int nbeats, int sz);
#+END_SRC

When a metanode is created, it creates the equivalent to
a monoramp, then binds a metanode to it.

#+NAME: funcs
#+BEGIN_SRC c
int gest_addmetanode(gest_d *g, int nbeats, int sz)
{
    int rc;
    gest_node *n;
    gest_metanode *mn;

    if (g->mnpos >= GEST_MNSTACK_SIZE) return 1;

    rc = gest_monoramp(g, nbeats);

    if (rc) return rc;

    n = g->curnode;

    mn = metanode_alloc(g, n, sz);

    n->meta = mn;
    n->get = node_seq;
    mn->parent = n;

    set_curnode(g, mn->nodes[mn->pos++]);

    g->mnstack[g->mnpos++] = mn;

    return 0;
}
#+END_SRC
** Addmetaphrase
The function =gest_addmetaphrase= will allocate a new
phrase of arbitrary size and division
(will be unused anyways), and then allocate a new instance
of a metaphrase with =sz= phrases.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_addmetaphrase(gest_d *g, int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_addmetaphrase(gest_d *g, int sz)
{
    gest_metaphrase *mp;
    gest_phrase *ph;

    if (g->mppos >= GEST_MPSTACK_SIZE) return 1;


    gest_begin(g, 1, 1);

    ph = g->phrase_selected;

    mp = metaphrase_alloc(g, sz);

    ph->get = phrase_seq;
    ph->meta = mp;
    mp->parent = ph;

    g->mpstack[g->mppos++] = mp;

    return 0;
}
#+END_SRC
** Randtarget
The function =gest_randtarget= configures the last
metatarget to choose targets randomly.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_randtarget(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_randtarget(gest_d *g)
{
    gest_metatarget *mt;
    if (g->mtpos <= 0) return 1;

    mt = g->mtstack[g->mtpos - 1];

    mt->parent->get = target_random;
    return 0;
}
#+END_SRC
** Randbehavior
The function =gest_randbehavior= configures the last
metabehavior to choose behaviors randomly.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_randbehavior(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_randbehavior(gest_d *g)
{
    gest_metabehavior *mb;

    if (g->mbpos <= 0) return 1;

    mb = g->mbstack[g->mbpos - 1];

    mb->parent->get = behave_random;
    return 0;
}
#+END_SRC
** Randnode
The function =gest_randnode= configures the last
metanode to choose nodes randomly.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_randnode(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_randnode(gest_d *g)
{
    gest_metanode *mn;

    if (g->mnpos <= 0) return 1;

    mn = g->mnstack[g->mnpos - 1];

    mn->parent->get = node_random;
    return 0;
}
#+END_SRC
** Randphrase
The function =gest_randphrase= configures the last
metaphrase to choose phrases randomly.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_randphrase(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_randphrase(gest_d *g)
{
    gest_metaphrase *mp;

    if (g->mppos <= 0) return 1;

    mp = g->mpstack[g->mppos - 1];

    mp->parent->get = phrase_random;
    return 0;
}
#+END_SRC
** Setscalar
Binds an action to the current that assings a value
to an instant of a =gest_scalar=.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_setscalar(gest_d *g, gest_scalar *s, SKFLT val);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_setscalar(gest_d *g, gest_scalar *s, SKFLT val)
{
    action_scalar(g, g->curtarget, s, val);
    return 0;
}
#+END_SRC
* Behavior Commands
Behaviors are the means by which one target gets to thep
next target.
** Linear
Linear: converts the last target to use linear behavior.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_linear(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT linear(gest_d *g, SKFLT a, void *ud)
{
    return a;
}

void gest_behavior_linear(gest_d *g)
{
    set_behavior(g, linear, NULL);
}
#+END_SRC
** Step
Step: converts the last target to be a step (no line, just
the value).

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_step(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT step(gest_d *g, SKFLT a, void *ud)
{
    return 0;
}

void gest_behavior_step(gest_d *g)
{
    set_behavior(g, step, NULL);
}
#+END_SRC
** Gliss
=Gliss= is a behavior intended
gestures that are pitches mimicking glissando.
It works by cutting the incoming ramp in half. The
first half is 0, and the second half gets
normalized to be 0-1 with a cubic slope. This
then gets interpolated between the x and y target
values.
*** Regular Gliss
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_gliss(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT gliss(gest_d *g, SKFLT a, void *ud)
{
    if (a < 0.5) {
        a = 0;
    } else {
        a -= 0.5;
        if (a < 0) a = 0;
        a *= 2;
        a = a * a * a;
    }

    return a;
}

void gest_behavior_gliss(gest_d *g)
{
    set_behavior(g, gliss, NULL);
}
#+END_SRC
*** Small Gliss
=smallgliss= does this, but smaller scale. Best for
instruments that want the minimal amount of smoothing
done to preserve a step-sequenced sound.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_smallgliss(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT smallgliss(gest_d *g, SKFLT a, void *ud)
{
    if (a < 0.97) {
        a = 0;
    } else {
        a -= 0.97;
        if (a < 0) a = 0;
        a /= 0.03;
        a = a * a * a;
    }
    return a;
}

void gest_behavior_smallgliss(gest_d *g)
{
    set_behavior(g, smallgliss, NULL);
}
#+END_SRC
*** Medium Gliss
Ideally tuned for voice.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_mediumgliss(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT mediumgliss(gest_d *g, SKFLT a, void *ud)
{
    if (a < 0.75) {
        a = 0;
    } else {
        a -= 0.75;
        if (a < 0) a = 0;
        a /= 0.25;
        a = a * a * a;
    }
    return a;
}

void gest_behavior_mediumgliss(gest_d *g)
{
    set_behavior(g, mediumgliss, NULL);
}
#+END_SRC
** Exponential
Exponential: converts the last target to use exponential
behavior with slope =slope=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_exponential(gest_d *g, SKFLT slope);
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_step(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT exponential(gest_d *g, SKFLT a, void *ud)
{
    SKFLT *s;

    s = ud;

    return (1.0 - exp(a * (*s))) / (1 - exp(*s));
}

void gest_behavior_exponential(gest_d *g, SKFLT slope)
{
    SKFLT *s;
    s = gest_alloc(g, sizeof(SKFLT));
    *s = slope;
    set_behavior(g, exponential, s);
}
#+END_SRC
** Bezier
Applies a quadratic Bezier line segment between to two
targets. Bezier takes in two control values that are
control targets.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_bezier(gest_d *g, SKFLT cx, SKFLT cy);
#+END_SRC

Explanation for how this works is already done in
the sndkit Bezier algorithm where this is
code is based, so it's worth checking
that out for the mathematical derivation.

#+NAME: funcs
#+BEGIN_SRC c
struct bezier_data {
    SKFLT cx;
    SKFLT cy;
};

/* https://pbat.ch/sndkit/bezier/ */

static SKFLT quadratic_equation(SKFLT a, SKFLT b, SKFLT c)
{
    SKFLT det; /* determinant */

    det = b*b - 4*a*c;

    if (det >= 0) {
        return ((-b + sqrt(det))/(2.0*a));
    } else {
        return 0;
    }
}

static SKFLT find_t(SKFLT x0, SKFLT x1, SKFLT x2, SKFLT x)
{
    SKFLT a, b, c;

    a = (x0 - 2.0 * x1 + x2);
    b = 2.0 * (-x0 + x1);
    c = x0 - x;

    if (a) {
        return quadratic_equation(a, b, c);
    } else {
        return (x - x0) / b;
    }
}

static SKFLT bezier_curve(SKFLT xpos, SKFLT cx, SKFLT cy)
{
    SKFLT x[3];
    SKFLT y[3];
    SKFLT t;
    SKFLT val;

    x[0] = 0;
    x[1] = cx;
    x[2] = 1;

    y[0] = 0;
    y[1] = cy;
    y[2] = 1;

    t = find_t(x[0], x[1], x[2], xpos);

    val = (1.0-t)*(1.0-t)*y[0] + 2.0*(1 - t)*t*y[1] + t*t*y[2];
    return val;
}

static SKFLT bezier(gest_d *g, SKFLT a, void *ud)
{

    struct bezier_data *bd;
    bd = ud;
    return bezier_curve(a, bd->cx, bd->cy);
}

void gest_behavior_bezier(gest_d *g, SKFLT cx, SKFLT cy)
{
    struct bezier_data *bd;
    bd = gest_alloc(g, sizeof(struct bezier_data));
    bd->cx = cx;
    bd->cy = cy;
    set_behavior(g, bezier, bd);
}
#+END_SRC
* Temporal Weight Commands
** mass
=gest_mass= the global mass to an absolute value.
Should be in range -120 to 120. 120 is a number chosen
for it's divisibility properties.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_mass(gest_d *g, SKFLT mass);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_mass(gest_d *g, SKFLT mass)
{
    action_mass(g, g->curtarget, mass);
}
#+END_SRC
** inertia
=gest_inertia= sets the inertia to be a absolute value.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_inertia(gest_d *g, SKFLT inertia);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_inertia(gest_d *g, SKFLT inertia)
{
    action_inertia(g, g->curtarget, inertia);
}
#+END_SRC
** TODO shrink/grow
=gest_shrink= and =gest_grow= cause the mass to shrink
and grow by a percentage value.
** TODO speedup/slowdown
=gest_speedup= and =gest_slowdown= cause the inertia
to grow or shrink by a certain amount.
* Phrases
A gesture is built of out of chunks known as as a =phrase=.
Phrases convert an incoming conductor signal into a single
monoramp, and then divide that monoramp into a polyramp.
** Struct Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_phrase gest_phrase;
#+END_SRC

#+NAME: struct_phrase
#+BEGIN_SRC c
struct gest_phrase {
    gest_node *top;
    SKFLT mod;
    int beats;
    gest_phrase *next;
    gest_metaphrase *meta;
    gest_phrase* (*get)(gest_d *, gest_phrase *);
};
#+END_SRC

The phrase forms the top of a Ramp Tree that gets populated.

When a phrase is over, it points to the next phrase. If
there is no phrase, it loops back to itself.
** Initialization
A phrase gets initialized with =phrase_init=. The duration
of the phrase, measured in beats, is supplied.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void phrase_init(gest_d *g,
                        gest_phrase *phrase,
                        int beats,
                        int div);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void phrase_init(gest_d *g,
                        gest_phrase *phrase,
                        int beats,
                        int div)
{
    phrase->mod = 1.0 / beats;
    phrase->beats = beats;
    phrase->next = NULL;
    phrase->top = mkpolyramp(g, NULL, div);
    phrase->meta = NULL;
    phrase->get = NULL;
}
#+END_SRC
* Ramp Tree
** The Ramp Tree Struct
*** Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_node gest_node;
#+END_SRC

#+NAME: struct_ramptree
#+BEGIN_SRC c
struct gest_node {
    <<gest_node>>
};
#+END_SRC

The Ramp Tree is a hierarchical tree data structure.
Nodes on the tree are contained in a struct known as
a =gest_node=. It is initialized with =gest_node_init=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void gest_node_init(gest_node *n);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void gest_node_init(gest_node *n)
{
    <<gest_node_init>>
}
#+END_SRC
*** Node Type (type)
The node =type= indicates whether or not is a =polyramp= or
a =monoramp=. By default, it is a null node.

#+NAME: gest_node
#+BEGIN_SRC c
int type;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->type = NODE_NOTHING;
#+END_SRC

#+NAME: enums
#+BEGIN_SRC c
enum  {
    NODE_NOTHING,
    NODE_POLYRAMP,
    NODE_MONORAMP
};
#+END_SRC
*** Modifier (modifier)
The =modifier= is a integer amount used to rescale the
incoming ramp signal.

#+NAME: gest_node
#+BEGIN_SRC c
int modifier;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->modifier = NODE_NOTHING;
#+END_SRC
*** Number of Children (nchildren)
The number of children a node has is stored by a variable
=nchildren=. The children nodes are stored in =children=
as a linked list, using the =next= entry.

#+NAME: gest_node
#+BEGIN_SRC c
int nchildren;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->nchildren = 0;
#+END_SRC
*** Children Nodes
The actual children of a particular node is contained
in a linked list (using the node itself as an entry point).
The node only stores the head of the list.

#+NAME: gest_node
#+BEGIN_SRC c
gest_node *children;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->children = NULL;
#+END_SRC
*** Node Target Value (target)
Every node can carry a =target=, though only leaves of
the tree can have targets. This value is otherwise left
empty.

#+NAME: gest_node
#+BEGIN_SRC c
gest_target *target;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->target = NULL;
#+END_SRC
*** Next Node in List (next)
Contiguous nodes that are children to a parent node are
linked together in a linked list, with each node
pointing to the next with a variable called =next=.

#+NAME: gest_node
#+BEGIN_SRC c
gest_node *next;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->next = NULL;
#+END_SRC
*** Parent Node (parent)
A pointer to the parent node is a way for nodes
to keep track of position while traversing or
populating the tree.

#+NAME: gest_node
#+BEGIN_SRC c
gest_node *parent;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->parent = NULL;
#+END_SRC
*** Node ID
used for debugging.

#+NAME: gest_node
#+BEGIN_SRC c
int id;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->id = -1;
#+END_SRC
*** Metanode
Holds optional data for a metanode. NULL by default.

#+NAME: gest_node
#+BEGIN_SRC c
gest_metanode *meta;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->meta = NULL;
#+END_SRC
*** Children Getter
Optional getter function that returns children of a node.

#+NAME: gest_node
#+BEGIN_SRC c
gest_node* (*get)(gest_d *, gest_node *);
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->get = NULL;
#+END_SRC
** Global Modifier Manipulation
The Ramp Tree manipulates the
underlying rephasor signal by manipulating the incrementor
value through multiplication or division.

Iteration through a node works slightly differently
depending on if it is a monoramp or a polyramp. A monoramp
keeps track of time from the input signal before finishing.
A polyramp keeps track of time using it's own synthesized
signal. Polyramps iterate through their children nodes,
which can recrusively call more monoramps and polyramps.

Every sample, the Tree Ramp moves forward in time and
computes a value. This value is fed into the current target
callback.

Nodes in the ramptree count. So, I guess some kind of
counter? We will use a counter and a limit, that way the
node can be reset multiple times. Every node updates it's
counter when it detects a reset.
** Populating a tree with nodes
The general concept populating a tree is that nodes are
created, then more nodes are created that become children
of the previous nodes. Population of a tree works from left
to right.

Creating a node is not only allocating a node, but also
appending it to be a child of the parent node. This
means all nodes need to have their parent present.

Linking the new node to the parent node is a matter of
appending to the end of the =children= list.
*** Creating a new polyramp node
A polyramp node is a node that takes one monoramp and
subdivides it into a fixed number of ramps. Each of
those ramps can be a potential child node.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node * mkpolyramp(gest_d *g,
                              gest_node *parent,
                              int div);
#+END_SRC

The new node is linked to the parent node by appending it
to the end of the child list. Before this happens, a quick
check is done to make sure the parent node isn't already
full.

#+NAME: funcs
#+BEGIN_SRC c
static gest_node * mkpolyramp(gest_d *g,
                              gest_node *parent,
                              int div)
{
    gest_node *n, *last;
    int total;

    /* check to see if parent node is full */

    total = 0;
    last = NULL;

    if (parent != NULL) {
        total = node_count(parent, &last);
        if (total >= parent->modifier) {
            return NULL;
        }
    }

    n = gest_alloc(g, sizeof(gest_node));
    gest_node_init(n);
    n->type = NODE_POLYRAMP;
    n->modifier = div;
    n->parent = parent;
    n->id = g->nodepos;
    g->nodepos++;

    if (parent != NULL) {
        append_node(parent, n, last);
    }

    if (parent == NULL) {
        n->parent = n;
    }

    return n;
}
#+END_SRC
*** Creating a new monoramp node
A monoramp node takes a contiguous set of children from
a polyramp node and merges them together into one ramp.
A monoramp can have only one potential child node.

The monoramp takes in the number of input ramp periods
it will span. It will verify there is enough room in the
parent node before creating.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node * mkmonoramp(gest_d *g,
                              gest_node *parent,
                              int ninputs);
#+END_SRC

Similar to =mkpolyramp=, the parent node is checked for
room.

#+NAME: funcs
#+BEGIN_SRC c
static gest_node * mkmonoramp(gest_d *g,
                              gest_node *parent,
                              int ninputs)
{
    gest_node *n, *last;
    int total;

    last = NULL;

    if (parent != NULL) {
        total = node_count(parent, &last);
        total += ninputs;
        if (total > parent->modifier) return NULL;
    }

    n = gest_alloc(g, sizeof(gest_node));
    gest_node_init(n);
    n->type = NODE_MONORAMP;
    n->modifier = ninputs;
    n->parent = parent;
    n->id = g->nodepos;
    g->nodepos++;

    if (parent != NULL) {
        append_node(parent, n, last);
    }

    return n;
}
#+END_SRC
** Some Ramp Tree Functions
*** Node Count
=node_count= counts the number of children in a node.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int node_count(gest_node *node, gest_node **last);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int node_count(gest_node *node, gest_node **last)
{
    int total;
    int i;
    gest_node *child;

    total = 0;

    if (node == NULL) {
        return -1;
    }

    child = node->children;

    for (i = 0; i < node->nchildren; i++) {
        if (child->type == NODE_MONORAMP) {
            /* monoramps eat up M ramps */
            total += child->modifier;
        } else if (child->type == NODE_POLYRAMP) {
            /* polyramps always occupy one ramp */
            total++;
        }

        if (last != NULL && i == node->nchildren - 1) {
            *last = child;
        }

        child = child->next;
    }

    return total;
}
#+END_SRC
*** Append Node to Parent
Append a node to a parent node with =append_node=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void append_node(gest_node *parent,
                        gest_node *node,
                        gest_node *last);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void append_node(gest_node *parent,
                        gest_node *node,
                        gest_node *last)
{
    if (last == NULL) {
        parent->children = node;
    } else {
        last->next = node;
    }

    parent->nchildren++;
}
#+END_SRC
*** Dive To Target
Dive into node tree until next target is found.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node * dive_to_target(gest_d *g,
                                  gest_node *node);
#+END_SRC

A special edge case is handled when target node is
a monoramp with a modifier greater than 1. It will
be explicitely applied before being returned.
The correspdoning reverting happens in =mktarget=
before the next target is set.

#+NAME: funcs
#+BEGIN_SRC c
static gest_node * dive_to_target(gest_d *g,
                                  gest_node *node)
{
    if (node->meta != NULL) node = get_node(g, node);

    if (node->target != NULL) {
        apply_modifier(g, node);
        return node;
    }

    while (node->target == NULL) {
        apply_modifier(g, node);

        /* go to left-most child */
        node = acquire_children(g, node);
        if (node == NULL) break;
    }

    if (node->type == NODE_MONORAMP && node->modifier > 1) {
        apply_modifier(g, node);
    }

    return node;
}
#+END_SRC
*** Revert/Apply Modifiers
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void revert_modifier(gest_d *g, gest_node *node);
static void apply_modifier(gest_d *g, gest_node *node);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void revert_modifier(gest_d *g, gest_node *node)
{
    if (node->type == NODE_POLYRAMP) {
        g->num /= node->modifier;
    } else if (node->type == NODE_MONORAMP) {
        g->den /= node->modifier;
    }
}
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void apply_modifier(gest_d *g, gest_node *node)
{
    if (node->type == NODE_POLYRAMP) {
        g->num *= node->modifier;
    } else if (node->type == NODE_MONORAMP) {
        g->den *= node->modifier;
    }
}
#+END_SRC
*** Acquiring Children From Nodes
Some level of abstraction now required for getting children
from Nodes. This is done to make metanodes possible, which
can change every time the node is descended upon.

For now, it just does the behavior it did before.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node* acquire_children(gest_d *g, gest_node *n);
static gest_node* get_node(gest_d *g, gest_node *n);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_node* get_node(gest_d *g, gest_node *n)
{
    while (n->get != NULL) {
        n = n->get(g, n);
    }

    return n;
}

static gest_node* acquire_children(gest_d *g, gest_node *n)
{
    gest_node *children;

    children = n->children;
    children = get_node(g, children);

    return children;
}
#+END_SRC
** Target Getter
The function =node_target= is used to get
the target associated with a node. This layer
of abstraction is needed for metatargets.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_target *node_target(gest_d *g, gest_node *node);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_target *node_target(gest_d *g, gest_node *node)
{
    gest_target *t;

    if (node == NULL) return NULL;

    t = node->target;

    if (node->target != NULL && node->target->get != NULL) {
        while (1) {
            t = t->get(g, t);
            if (t->meta == NULL) break;
        }
    }

    return t;
}
#+END_SRC
* Stepping Through The Ramp Tree
A big part of gest involves stepping through a ramp tree.
A ramp tree produces a set of normalized ramp values
from 0 to 1, whose period lengths are proportional
to the external conductor signal. These values
can then be used to interpolate between targets.

The ramp tree value is computed with =ramptree_step=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset)
{
    SKFLT out;
    SKFLT phs;

    out = 0;

    phs = g->phs;

    if (g->phrase_selected == NULL) return phs;

    <<beat_checkin>>

    inc *= g->phrase_selected->mod * g->correction;

    <<set_the_output>>
    <<update_targets>>
    <<update_phase>>
    <<check_and_update>>

    g->phs = phs;
    g->t += inc;

    return out;
}
#+END_SRC
** Beat Check-in
In order to combat clock drift, a phrase "checks in" every
time conductor signal resets, which is an indicator of the
new beat. Every time a new beat occurs, the status of the
phrase is figured out, and handled accordingly.

Clock drift naturally occurs within Gest because it
resynthesizes a new timing signal based on the external
conductor signal. Left unchecked, Gestures will eventually
fall out of time with the conductor due to the fact that
they are marching to the beat of their own drum.

The coarse way that clock drift is managed is by keeping
drift localized within the phrase. A phrase is allocated
to be a fixed number of beats. When the conductor goes
on to the next beat, the current phrase, wherever it may
be in its performance, is discarded, and the clock drift
debt is reset.

Gestures are a game of constant imprecision. Their timing
can either be late or early, but never quite on time.
Early gestures occur when a
phrase finishes before the conductor. When this happens, it
is told to wait, returning 1 until the first downbeat of the
next phrase. Late
phrases don't quite make it to the end of their gesture.
When this happens, the phrase bails and jumps to the next
one. The hope is that they are close enough to prevent an
audible glitch.

During the check-in, the ideal position, obtained from
the beat counter and known as the =goal=,
can be compared with the actual position =t=. These two
values can be used to create a course correction factor,
which allows the gesture to slow down or speed up to more
closely match the conductor signal.

#+NAME: beat_checkin
#+BEGIN_SRC c
if (reset) {
    int limit;
    SKFLT goal;

    limit = g->phrase_selected->beats;
    g->beat++;
    goal = (SKFLT) g->beat / limit;

    if (g->t > 0) g->correction = goal / g->t;

    if (g->beat >= limit) {
        g->beat = 0;
        g->t = 0;
        g->phs = 0;
        g->please_wait = 0;
        g->correction = 1.0;
        g->targetondeck = 1;
        g->phrase_selected = g->nxtstate.phrase;

        /* reset if next state was told to wait */
        g->nxtstate.please_wait = 0;
        return phs;
    }
} else if (g->please_wait) {
    return 1.0;
}
#+END_SRC
** Setting the Output
The point of this function is to update the overall state of
the ramp trees in gest and return a corresponding ramp
value.

The returned value is the computation done on the previous
call to =ramptree_step=.

#+NAME: set_the_output
#+BEGIN_SRC c
out = g->phs;
#+END_SRC
** Updating Targets
A set =targetondeck= flag will not only be
used to change the target, but also the state information
that comes with the target, such as the node, the phrase,
and the conductor modifier associated with the target.

It is also here that the next node is found. Information
for the next node needs to be immediately available, as
certain tools using and extending gest (such as the vocal
tract interpolation work) rely on knowing about
the next target for it to work properly.

It is assumed that by the time =targetondeck= is found,
the next node is already in place (presumably
from the last time targetondeck was set, or initialization),
and just needs to be swapped in.

=please_wait= is cached as state, and gets turned on during
=find_next_node=.

#+NAME: update_targets
#+BEGIN_SRC c
if (g->targetondeck) {
    gest_state *s;
    s = &g->nxtstate;

    g->targetondeck = 0;

    if (s->please_wait) {
        g->please_wait = 1;
        return 1.0;
    }

    g->num = s->num;
    g->den = s->den;
    s->target->curbehavior = s->behavior;
    set_curtarget(g, s->target);

    set_curnode(g, s->node);
    g->phrase_selected = s->phrase;

    init_state(&g->nxtstate);

    if (g->curnode != NULL) {
        find_next_node(g, g->curnode, &g->nxtstate);
    }

    g->nxttarget = g->nxtstate.target;

    if (g->nxttarget != NULL) {
        g->nxtval = g->nxttarget->value;
    } else {
        g->nxtval = g->curval;
    }
}
#+END_SRC

What triggers =targetondeck=? Usually this happens when the
internal ramp reaches the end. This can also be triggered
during the beat check-in, when a conductor signal demands
to jump to the next phrase before fully finishing the
current one.
** Updating the phase using modifier and friends
To begin, the modifier amount is calculated.

The modifier and increment amount are used together to
update the existing phase.

#+NAME: update_phase
#+BEGIN_SRC c
{
SKFLT i;
i = inc * ((SKFLT)g->num / g->den);
phs += i;
}
#+END_SRC

The phase is then checked to see if it has exceeded 1.
If it has, a change in nodes is required.

#+NAME: check_and_update
#+BEGIN_SRC c
if (phs > 1.0) {
    <<goto_next_node>>
    <<wraparound>>
}
#+END_SRC
** Signalling to go to the next target
When the ramp reaches the end, it is time to go on to the
next node with a target. By the time it reaches this point,
this node has already been found, and just needs to be
signalled to switch with the variable =targetondeck=.

#+NAME: goto_next_node
#+BEGIN_SRC c
g->targetondeck = 1;
#+END_SRC
** Finding the next node in the Ramp Tree
When a new node begins, the next with a target
in the ramp tree must be found immediately after.
Many programs using Gest require knowing the next target.

The next node is found by traversing the Ramp
Tree based on the position the current node is in.

The process of finding the next node is done in a function
called =find_next_node=. It will find the next node, and
store the results in an instance of =gest_state=. The
=top= node is expected to be the currently selected node
=curnode=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void find_next_node(gest_d *g,
                           gest_node *top,
                           gest_state *state);
#+END_SRC

Traversal starts large and gets smaller.

To begin, check and see if the next node happens to be in
the next phrase. That would mean the currently selected
node is the right-most node (no nodes after it)
in the top of the tree. If this is true, it is time to
*wait* for the next phrase on the next down beat. If the
next phrase is being found here, it has arrived a tad too
early (which is actually better than being a
tad too late, as it turns out. It's one or the other here).

If it's not the top of the tree, there is a general check
to see if the current node is the right-most node relative
to the position in the tree. If so, the node reverts the
global modification it did, and goes up one level to the
parent node to check the next node there.

Finally, the next node is found, and the program recursively
dives into it to find the next target, applying modifiers
along the way. Before that happens, the current node *may*
need to revert the global modifier if it is a monoramp
with a modifier greater than 1.

If the next node happens to be a monoramp with a modifier
greater than 1, it will also apply modifications. But should
be handled inside of =dive_to_target=. If the node is already
a target with a monoramp >1, this gets applied here as a
special exception.

#+NAME: funcs
#+BEGIN_SRC c
static void find_next_node(gest_d *g,
                           gest_node *top,
                           gest_state *state)
{
    gest_node *next;
    gest_node *last_reverted;
    gest_phrase *phrase;
    int num, den;
    int please_wait;

    next = NULL;
    last_reverted = NULL;

    num = g->num;
    den = g->den;
    phrase = g->phrase_selected;
    please_wait = 0;

    while (next == NULL) {
        if (top == g->phrase_selected->top) {
            /* are we at the end */
            /* if so, go to next phrase */
            if (top->next == NULL) {
                /* next node is in next phrase */
                phrase = phrase->next;
                phrase = get_phrase(g, phrase);
                if (phrase != NULL) next = phrase->top;
                else next = NULL;
                g->num = 1;
                g->den = 1;
                if (next != NULL) {
                   next = dive_to_target(g, next);
                }
                please_wait = 1;
                break;
            } else {
                /* go to next child in top polyramp node */
                next = top->next;

                if (next->target == NULL) {
                    next = dive_to_target(g, next);
                }
            }
        } else if (top->next == NULL) {
            revert_modifier(g, top->parent);
            last_reverted = top->parent;
            top = top->parent;
        } else {
            next = top->next;

            /* if top is a monoramp >1, revert it */

            if (top != last_reverted) {
                if (top->type == NODE_MONORAMP && top->modifier > 1) {
                    /* revert the monoramp */
                    revert_modifier(g, top);
                }
            }

            /* dive_to_target applies modifiers */
            /* continguous nodes on the same level don't have these */
            if (next->target == NULL) {
                next = dive_to_target(g, next);
            } else if (next->type == NODE_MONORAMP && next->modifier > 1) {
                /* next node is on same level but is monoramp */
                apply_modifier(g, next);
            }

        }
    }


    state->num = g->num;
    state->den = g->den;
    state->node = next;
    state->target = node_target(g, next);
    state->behavior = target_behavior(g, state->target);
    state->phrase = phrase;
    state->please_wait = please_wait;

    /* restore old numerator and denominator */

    g->num = num;
    g->den = den;
}
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_phrase* get_phrase(gest_d *g, gest_phrase *ph);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_phrase* get_phrase(gest_d *g, gest_phrase *ph)
{
    if (ph == NULL) return NULL;
    while (ph->get != NULL) ph = ph->get(g, ph);
    return ph;
}
#+END_SRC
** When a phrase is over, wraparound
A phrase is considered over when it reaches the end of the
top-level polyramp. At this point, the next phrase is found
and set to be the beginning of that node.

All ramps begin exactly at 0. When wraparound happens,
the roundoff error is stored in the error variable.

#+NAME: wraparound
#+BEGIN_SRC c
while (phs > 1) phs--;
phs = 0;
#+END_SRC
** Handling Roundoff Error in Phrases
Roundoff error is a natural part of working with floating
point, and difficult to avoid entirely. Roundoff error
in this context leads to temporal drift in the timing
signal. Unchecked, this will eventually lead to phrases
being completly out of step with the rest of the music
surrounding it.

Chunking gestures into phrases helps thwart some of the
major drift buildup that can occur over time. Phrases
ensure that any drift is localized, which, if the phrases
are small enough, should be quite negligible for most
musical purposes.

The Ramp Tree in a phrase applies many manipulations to a
phasor signal, and this can cause phrases to either finish
too quickly or too slowly. If choosing one or the other,
finishing too quickly is always the preference.

If a phrase ends before the conductor does, it is told to
wait. While waiting, it will only return 1 without updating
any state. When the conductor finally does catch up, the
phrase will be granted permission to move on to the next
phrase.

Every time the phasor in a conductor signal resets (wraps
back), it registered as a new beat. This beat gives gest
an opportunity to "check in" with itself. Is it going ahead
of schedule? Behind? And then, try to make the appropriate
corrections.

The progress of a phrase is kept inside of a monoramp that
spans the duration of the phrase, and the beat position is
kept track of as a sort of counter. A new beat indicates the
ideal time position, which can be compared against the the
actual position in the progress monoramp.

Dividing the ideal position and actual position gives us
a correction factor that slightly speeds up or slows down
the phasor within the beat. If the ideal is a bit farther
along, the correction factor will be a value greater than 1
that runs to catch up. If the ideal is a bit behind, the
factor will be less than 1, and will hold things back until
the next beat.

With any luck, the phrase will end just slightly before
the conductor, allowing it to wait for the next signal.
This happens when the monoramp exceeds 1 and/or the ramp
tree hits the end of the phrase. At any rate, a flag is set.

There can also be cases where the phrase is too slow.
Hopefully, it is fast enough to be wrapping up the last
target in the ramp tree. This is detected when a beat
happens that is past the duration of the phrase. When
this happens, the phrase is reset early, and caution
is scattered to the wind. It's not an ideal situation, as
this has the potential to create an audible glitch in the
gesture.
* Memory Collections
Memory-allocated things are managed in a data type known
as a =collection=. Data allocated in a collection can be
then used on things like targets, ramp trees, phrases, and
extra things needed by behaviors.
** Struct Declarations
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_collection gest_collection;
#+END_SRC

A collection is a linked list of generic pointers.

#+NAME: struct_collection
#+BEGIN_SRC c
<<struct_collection_entry>>
struct gest_collection {
    struct gest_entry *tail;
    int nitems;
};
#+END_SRC

A linked list entry contains a generic pointer
and an optional destructor callback that can free
any additional memory allocated and bound to the
pointer by the user.

#+NAME: struct_collection_entry
#+BEGIN_SRC c
struct gest_entry {
    void *ptr;
    void (*free)(void *);
    struct gest_entry *prev;
};
#+END_SRC
** Initialization
The collection is initialized with =collection_init=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void collection_init(gest_collection *col);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void collection_init(gest_collection *col)
{
    col->tail = NULL;
    col->nitems = 0;
}
#+END_SRC
** Allocating Memory
Anytime Gest needs to allocate memory, the gesture
system uses an instance of the allocator.
*** Allocation with Destructor Callback
The core function for memory allocation is
=collection_alloc_dtor=. In addition to providing the size,
an a user-defined destructor callback function. Note that
the allocated memory here is already being managed, and that
this is only used for any additional memory allocated inside
of it.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void * collection_alloc_dtor(gest_collection *col,
                                    size_t sz,
                                    void (*free)(void*));
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void * collection_alloc_dtor(gest_collection *col,
                                    size_t sz,
                                    void (*free)(void*))
{
    struct gest_entry *ent;

    ent = malloc(sizeof(struct gest_entry));

    ent->ptr = calloc(1, sz);
    ent->free = free;

    ent->prev = col->tail;
    col->tail = ent;
    col->nitems++;

    return ent->ptr;
}
#+END_SRC
*** Memory allocation only
Much of the time the destructor is not needed, so a more
convenient =collection_alloc= function is provided.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void * collection_alloc(gest_collection *col, size_t sz);
#+END_SRC

Creates a new entry, allocates a void pointer, appends the
entry to the list, then returns the pointer.

#+NAME: funcs
#+BEGIN_SRC c
static void * collection_alloc(gest_collection *col, size_t sz)
{
    return collection_alloc_dtor(col, sz, NULL);
}
#+END_SRC
*** Gesture Allocator Helper functions
The static function =gest_alloc= is a helper function
which mostly exists to make code look cleaner.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void * gest_alloc(gest_d *gest, size_t sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void * gest_alloc(gest_d *gest, size_t sz)
{
    return collection_alloc(&gest->col, sz);
}
#+END_SRC

** Freeing The Collection
All previously allocated memory in Gest can be freed with
the function =collection_cleanup=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void collection_cleanup(gest_collection *col);
#+END_SRC

Iterate through the linked list and free it all.

Note that the linked list moves backwards from
the tail to the head so that the most recently allocated
stuff gets freed first. This is done to minimize situations
where allocated items are somehow required to exist before
being freed.

#+NAME: funcs
#+BEGIN_SRC c
static void collection_cleanup(gest_collection *col)
{
    int n;
    struct gest_entry *ent, *prev;

    ent = col->tail;

    for (n = 0; n < col->nitems; n++) {
        prev = ent->prev;
        if (ent->free != NULL) ent->free(ent->ptr);
        free(ent->ptr);
        free(ent);
        ent = prev;
    }
}
#+END_SRC
* Targets and Behaviors
Targets can be contained inside of a node. If the tree
reaches a node with a target, it sets it to be that target
when the node starts.
** Struct Declaration
A target in gest is known as a =gest_target=

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_target gest_target;
#+END_SRC

A target stores 3 main things: a scalar value, a callback, and
some user data. The callback is a function that takes 4
arguments, the gest struct, the internal value, the
position, the next value,
and user data. It returns a floating point value.

Targets need to managed in their own linked list, in
addition to being referenced in the node they belong to.
Targets need to know what target is coming next (if there
is one coming next).

#+NAME: struct_gest_target
#+BEGIN_SRC c
<<gest_behavior>>
<<gest_actionlist_struct>>
struct gest_target {
    SKFLT value;
    gest_behavior behavior;
    gest_behavior *curbehavior;
    void *ud; /* user data attached to this target */
    gest_target *next;
    gest_target* (*get)(gest_d *, gest_target *);
    gest_metatarget *meta;
    <<gest_target>>
};
#+END_SRC
** Initialization
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_target_init(gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_target_init(gest_target *t)
{
    t->value = 0;
    t->ud = NULL;
    t->next = NULL;
    t->get = NULL;
    t->meta = NULL;
    gest_behavior_init(&t->behavior);
    t->curbehavior = &t->behavior;
    <<gest_target_init>>
}
#+END_SRC
** Binding Targets to Ramp Tree Nodes
Every target created is bound to exactly one node in a ramp
tree. Such a binding indicates a terminal leaf node in the
tree.

Creating targets are an important operation because
it is the thing that moves the tree forward (from left
to right) in population.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_target * mktarget(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_target * mktarget(gest_d *g)
{
    gest_target *t;
    gest_node *last;
    gest_node *curnode;

    t = NULL;
    last = NULL;
    curnode = g->curnode;

    <<create_target>>

    if (g->mtpos > 0) {
        <<tie_to_metatarget>>
        return t;
    }

    if (curnode == NULL) {
        return NULL;
    }

    <<check_current_node>>
    <<tie_to_node>>
    <<move_forward>>

    return t;
}
#+END_SRC

Data for a new target is allocated and initialized. What
to do with the target remains to be seen.

#+NAME: create_target
#+BEGIN_SRC c
t = gest_alloc(g, sizeof(gest_target));
gest_target_init(t);
#+END_SRC


A check is done to see if the current node can have
a target applied in the first place.

#+NAME: check_current_node
#+BEGIN_SRC c
{
    int size;

    size = node_count(curnode, &last);

    if (curnode != NULL && size >= curnode->modifier) {
        return NULL;
    }
}
#+END_SRC

Technically, a target is bound to the last created node,
which is always a monoramp.
But these
monoramps don't have to be explicitely created. Example:
"polyramp(3), target, target, target" will create a polyramp
node with 3 divisions and populate each one of those
divisisons (a monoramp) with a target (called one after
another 3 times). So, how to deal with that? By checking
the type of the last created child. If it exists at all,
it is always going to be a monoramp and never a polyramp,
due to the left-to-right method of population (new
polyramps always get selected to be the active node).
A monoramp's target can be checked if it is occupied. A new
target is bound to an unoccupied monoramp target. Otherwise,
a new monoramp with a modifier of 1 is created to house
the new target.

#+NAME: tie_to_node
#+BEGIN_SRC c
{
    int rc;

    rc = last != NULL &&
        last->type == NODE_MONORAMP &&
        last->meta == NULL &&
        last->target == NULL &&
        last->nchildren == 0;

    if (rc) {
        last->target = t;
    } else {
        rc = curnode->type == NODE_MONORAMP &&
            curnode->target == NULL;

        if (rc) {
            curnode->target = t;
        } else {
            gest_node *mr;
            mr = mkmonoramp(g, curnode, 1);
            mr->target = t;
        }
    }
}
#+END_SRC

Targets are the things that move the ramp tree forward in a
left-to-right fashion when it is being populated.

A movement to the next available node happens when the
current node has been filled up. When this happens, it will
attempt to move up a level to find free slots there. This
will continue to happen until a free slot is found, or it
reaches the end of the phrase.

#+NAME: move_forward
#+BEGIN_SRC c
{
    gest_node *next;
    gest_node *curr;
    int metahunt;
    gest_node *mnpar;

    next = NULL;
    curr = curnode;
    metahunt = 0;
    mnpar = NULL;

    <<check_metanode_stack>>

    while (next == NULL) {
        int size;
        gest_node *last;
        int limit;

        <<check_for_metanode_parent>>

        /* is there any room in the current node? */

        size = node_count(curr, &last);

        if (curr->type == NODE_MONORAMP) {
            limit = curr->nchildren;
        } else {
            limit = curr->modifier;
        }

        /* no room ... */
        if (size >= limit) {
            /* onto the next... */

            /* we've reached the top */
            if (curr == curr->parent) break;

            /* try one level up */

            curr = curr->parent;

        } else {
            /* this node has room! */
            next = curr;
        }
    }

    set_curnode(g, next);
}
#+END_SRC

If there is a metatarget being active populated, the target
will be sent there instead of being tied to a node. The most
recent metatarget in play is retrieved via the metatarget
stack, and a target is appeneded. If it has reached the end,
the metatarget itself is popped off the stack here.

#+NAME: tie_to_metatarget
#+BEGIN_SRC c
gest_metatarget *mt;

/* get from top of stack */
mt = g->mtstack[g->mtpos - 1];

/* append to targets array */
mt->targets[mt->pos++] = t;

/* pop off stack if reached the end */
if (mt->pos >= mt->size) {
    g->mtpos--;
    g->mtstack[g->mtpos] = NULL;
    mt->pos = 0;
}
#+END_SRC
** Temporal Weight
Targets have temporal mass and inertia. These values
can be used to slow down or speed up the global tempo in
the conductor signal generator. Mass is the amount used to
speed up or slowdown the tempo. Inertia is the speed at
which it changes.

When a target changes global inertia or mass, it does so
through an action.

The current actions implemented include directly setting
the mass and inertia values. The action callbacks for these
are =update_mass= and =update_inertia=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void update_mass(gest_d *g, void *ud, int pos);
static void update_inertia(gest_d *g, void *ud, int pos);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void update_mass(gest_d *g, void *ud, int pos)
{
    SKFLT *mass;
    mass = (SKFLT *) ud;
    g->mass = *mass;
}

static void update_inertia(gest_d *g, void *ud, int pos)
{
    SKFLT *inertia;
    inertia = (SKFLT *) ud;
    g->inertia = *inertia;
}
#+END_SRC

These can be appended to targets with =action_mass=
and =action_inertia=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void action_mass(gest_d *g, gest_target *t, SKFLT mass);
static void action_inertia(gest_d *g, gest_target *t, SKFLT interia);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void action_mass(gest_d *g, gest_target *t, SKFLT mass)
{
    SKFLT *pmass;

    pmass = gest_alloc(g, sizeof(SKFLT));
    *pmass = mass;

    append_action(g, t, update_mass, pmass);
}

static void action_inertia(gest_d *g, gest_target *t, SKFLT inertia)
{
    SKFLT *pinertia;

    pinertia = gest_alloc(g, sizeof(SKFLT));
    *pinertia = inertia;

    append_action(g, t, update_inertia, pinertia);
}
#+END_SRC
** Mix Callback
The =mix= callback is the callback used to interpolate
between the current value and the next value, given an
alpha value generated from the ramp tree.

#+NAME: gest_target
#+BEGIN_SRC c
SKFLT (*mix)(gest_d *, SKFLT, SKFLT, SKFLT);
#+END_SRC

By default, mixing is just a linear crossfade between
two the two values. This is defined in the callback
=default_mix=:

#+NAME: gest_target_init
#+BEGIN_SRC c
t->mix = default_mix;
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static SKFLT default_mix(gest_d *g, SKFLT x, SKFLT y, SKFLT a);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT default_mix(gest_d *g, SKFLT x, SKFLT y, SKFLT a)
{
    return (1 - a)*x + a*y;
}
#+END_SRC

The mix callback can be updated using the function
=gest_target_mix=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_target_mix(gest_target *t,
                     SKFLT (*mix)(gest_d *, SKFLT, SKFLT, SKFLT));
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_target_mix(gest_target *t,
                     SKFLT (*mix)(gest_d *, SKFLT, SKFLT, SKFLT))
{
    t->mix = mix;
}
#+END_SRC
** Set/get user data
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_target_data_set(gest_target *t, void *ud);
void* gest_target_data_get(gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_target_data_set(gest_target *t, void *ud)
{
    t->ud = ud;
}

void* gest_target_data_get(gest_target *t)
{
    return t->ud;
}
#+END_SRC
** Behaviors
Behaviors are the things that dictate how one target
goes to the next target. A behavior is a callback
function. It is a function that takes in a value from 0 to
1, and then returns a new value assumed to also be in the
same range. Behaviors can also have their own state to
manage things like parameters and constants.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_behavior gest_behavior;
typedef SKFLT (* gest_bfunc) (gest_d *, SKFLT, void *);
#+END_SRC

#+NAME: gest_behavior
#+BEGIN_SRC c
struct gest_behavior {
    gest_bfunc tick;
    void *ud;
    gest_behavior * (*get)(gest_d *, gest_behavior *b);
    gest_metabehavior *meta;
};
#+END_SRC

Initialize the behavior with =gest_behavior_init=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_init(gest_behavior *b);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_behavior_init(gest_behavior *b)
{
    b->tick = NULL;
    b->ud = NULL;
    b->get = NULL;
    b->meta = NULL;
}
#+END_SRC

Set the behavior with =gest_behavior_set=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_set(gest_behavior *b, gest_bfunc tick, void *ud);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_behavior_set(gest_behavior *b, gest_bfunc tick, void *ud)
{
    b->tick = tick;
    b->ud = ud;
}
#+END_SRC

call the tick function with =gest_behavior_tick=.

#+NAME: funcdefs
#+BEGIN_SRC c
SKFLT gest_behavior_tick(gest_behavior *b, gest_d *g, SKFLT a);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
SKFLT gest_behavior_tick(gest_behavior *b, gest_d *g, SKFLT a)
{
    return b->tick(g, a, b->ud);
}
#+END_SRC
** Behavior Getter From Target
#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_behavior * target_behavior(gest_d *g, gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_behavior * target_behavior(gest_d *g, gest_target *t)
{
    gest_behavior *b;

    if (t == NULL) return NULL;

    b = &t->behavior;

    if (b != NULL && b->get != NULL) {
        while (1) {
            b = b->get(g, b);
            if (b->meta == NULL || b->get == NULL) break;
        }
    }

    return b;
}
#+END_SRC
* Computation
Gest is synthesized with =gest_tick=. It expects
a conductor phasor signal =conductor=.

#+NAME: funcdefs
#+BEGIN_SRC c
SKFLT gest_tick(gest_d *g, SKFLT conductor);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
SKFLT gest_tick(gest_d *g, SKFLT conductor)
{
    SKFLT out;
    SKFLT inc;
    int reset;

    out = 0;

    <<ignore_negative_values>>
    <<analysis>>
    <<compute_ramptree>>
    <<apply_targets>>
    <<update_previous_value>>

    g->prevout = out;
    return out;
}
#+END_SRC

Negative values in the conductor hold no meaning, so if one
pops up, gesture computation is ignored and the previously
cached output value is returned, effectively "pausing" gest.
This feature was added more recently so that gest could
work well with a sndkit algorithm called =clkphs=, which
converts a clock signal into a gest-compatible phasor
signal. clkphs requires some initial time in the beginning
to compute the first period of the phasor, and during that
time it returns -1.

#+NAME: ignore_negative_values
#+BEGIN_SRC c
if (conductor < 0) return g->prevout;
#+END_SRC

Analysis. The conductor signal is analyzed, and used to
drive the timing in the Ramp Tree. The previous conductor
signal is subtracted from the current one to produce
the phasor increment amount =inc=.

A phase reset is detected if the current conductor value
is less than the previous. A reset flag is set, and
the sign of the increment value is flipped to be positive.

For reasons I don't understand at the moment, it seems
that the first reset found at initialization needs to be
discounted, so there is logic built in here to handle that.

#+NAME: analysis
#+BEGIN_SRC c
inc = conductor - g->last;
reset = 0;

if (conductor < g->last) {
    inc = g->last_inc;
    reset = 1;
}

g->last_inc = inc;

/* discount reset found at initial sample */
if (g->phs == -1) {
    g->phs = 0;
    reset = 0;
}

g->last = conductor;
#+END_SRC

Conductor analysis components, the ramp tree can then be
computed with =ramptree_step=, which updates the state of
the tree and returns the tramptree value.

#+NAME: compute_ramptree
#+BEGIN_SRC c
out = ramptree_step(g, inc, reset);
#+END_SRC

With the computed ramp tree value in hand, the current
target's tick function can be called. This function returns
the output gesture.

#+NAME: apply_targets
#+BEGIN_SRC c
if (g->curtarget != NULL) {
    out = gest_behavior_tick(g->curtarget->curbehavior, g, out);
    out = g->curtarget->mix(g, g->curval, g->nxtval, out);
}
#+END_SRC

Right before the value is returned, the current output
is cached in the =prevout= variable.

#+NAME: update_previous_value
#+BEGIN_SRC c
g->prevout = out;
#+END_SRC
* Metathings
All things meta. Generally speaking, anything in this
section refers to any component in Gest capable of changing
itself after it has been created.
** Metatargets
Metatargets will probably end up in
a larger category of meta-things, including metaramps
and metabehaviors. But metatargets come first.
*** Overview
A metatarget is a target containing one or more
targets inside of itself. Whenever it gets selected
it can choose one of these targets. In other words,
this allows a particular target to dynamically
change every time the phrase it is contained in is played.

When metatargets are created, the number of
targets must be known ahead of time. Targets
created after the metatarget get automatically
appended to the metatarget until there is no
more room left.
*** Struct Declaration
A metatarget is a special struct stored inside
of a target inside via user-data pointer provided.
It contains an array of target pointers, the size,
and variable storing the current position.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_metatarget gest_metatarget;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
struct gest_metatarget {
    int pos;
    int size;
    gest_target *parent;
    gest_target **targets;
};
#+END_SRC
*** Metatarget Allocation
A metatarget is allocated with the function
=metatarget_alloc=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_metatarget * metatarget_alloc(gest_d *g, int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_metatarget * metatarget_alloc(gest_d *g, int sz)
{
    gest_metatarget *mt;
    int t;

    mt = gest_alloc(g, sizeof(gest_metatarget));
    mt->size = sz;
    mt->pos = 0;
    mt->targets = gest_alloc(g, sizeof(gest_target) * sz);

    for (t = 0; t < sz; t++) {
        mt->targets[t] = NULL;
    }

    return mt;
}
#+END_SRC
*** Metatarget Population
Metatarget population in Gest works by caching the
metatarget inside of the Gest struct. When a metatarget
is first created, it is set to be that value and
the position is set to be 0. Every time a target is added,
it will append to a metatarget instead of binding to a
phrase and increment the position. When the position reaches
the limit, the metatarget cache value is emptied.

Nested metatargets will need to use what will be
a fixed-size metatarget stack.
When a value is emptied, it is also popped from the stack.

A depth of 4 for
now will be used. If I need it to go deeper than that,
it will be changed.

#+NAME: gest_d
#+BEGIN_SRC c
#define GEST_MTSTACK_SIZE 4
gest_metatarget *mtstack[GEST_MTSTACK_SIZE];
int mtpos;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
{
    int i;

    for (i = 0; i < GEST_MTSTACK_SIZE; i++) {
        g->mtstack[i] = NULL;
    }

    g->mtpos = 0;
}
#+END_SRC

See =gest_addmetatarget= function for more usage
on this stack.
*** Sequential Target Selector
By default, a metatarget will choose targets in sequence.
This is done by overriding the default "get" callback
in the target.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_target *get_seq(gest_d *g, gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_target *get_seq(gest_d *g, gest_target *t)
{
    gest_metatarget *mt;

    mt = t->meta;

    if (mt->pos >= mt->size) mt->pos = 0;

    return mt->targets[mt->pos++];
}
#+END_SRC
*** Random Target Selector
The random target chooser =target_random= will
randomly choose a target from a metatarget.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_target *target_random(gest_d *g, gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_target *target_random(gest_d *g, gest_target *t)
{
    gest_metatarget *mt;

    mt = t->meta;

    return mt->targets[gest_randi(g, mt->size)];
}
#+END_SRC
** Metabehaviors
*** Overview
The metabehavior is a special kind of behavior that is a
collection of behaviors. Every time a target a metabehavior
belongs to is selected, it has the ability to change
which behavior is used.
*** Struct Declaration
Data for the metabehavior is encapsulated in a struct called
=gest_metabehavior=. It contains an array of behaviors, the
size, and a variable storing the current position.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_metabehavior gest_metabehavior;
#+END_SRC

Note that unlike metatargets, the =behaviors= array
is an array of behaviors, not an array of pointers.
Behaviors don't naturally get allocated the same way
targets do in the gest system, so they are explicitely
allocated here.

#+NAME: structs
#+BEGIN_SRC c
struct gest_metabehavior {
    int pos;
    int size;
    gest_behavior *parent;
    gest_behavior *behaviors;
};
#+END_SRC
*** Metabehavior allocation
A metabehavior is allocated with the function
=metabehavior_alloc=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_metabehavior * metabehavior_alloc(gest_d *g, int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_metabehavior * metabehavior_alloc(gest_d *g, int sz)
{
    gest_metabehavior *mb;
    int b;

    mb = gest_alloc(g, sizeof(gest_metatarget));
    mb->size = sz;
    mb->pos = 0;
    mb->behaviors = gest_alloc(g, sizeof(gest_behavior) * sz);

    for (b = 0; b < sz; b++) {
        gest_behavior_init(&mb->behaviors[b]);
        gest_behavior_set(&mb->behaviors[b], linear, NULL);
    }

    return mb;
}
#+END_SRC
*** Population (via Stack)
Similar to the metatargets, population is done with a stack
of metabehaviors.

#+NAME: gest_d
#+BEGIN_SRC c
#define GEST_MBSTACK_SIZE 4
gest_metabehavior *mbstack[GEST_MBSTACK_SIZE];
int mbpos;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
{
    int i;

    for (i = 0; i < GEST_MBSTACK_SIZE; i++) {
        g->mbstack[i] = NULL;
    }

    g->mbpos = 0;
}
#+END_SRC

All behaviors can automatically be appended to metabehaviors
instead of targets when they use =set_behavior=.

First, it will check the metabehavior stack, and append
there. Otherwise it will set to the current target directly.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void set_behavior(gest_d *g, gest_bfunc tick, void *ud);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void set_behavior(gest_d *g, gest_bfunc tick, void *ud)
{
    gest_behavior *b;

    b = &g->curtarget->behavior;

    if (g->mbpos > 0) {
        gest_metabehavior *mb;

        mb = g->mbstack[g->mbpos - 1];

        b = &mb->behaviors[mb->pos++];

        if (mb->pos >= mb->size) {
            mb->pos = 0;
            g->mbstack[g->mbpos - 1] = NULL;
            g->mbpos--; /* don't be clever */
        }
    }

    gest_behavior_set(b, tick, ud);
}
#+END_SRC
*** Sequentional Behavior Selector
#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_behavior* behave_seq(gest_d *g, gest_behavior *b);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_behavior* behave_seq(gest_d *g, gest_behavior *b)
{
    gest_metabehavior *mb;

    mb = b->meta;

    if (mb->pos >= mb->size) mb->pos = 0;

    return &mb->behaviors[mb->pos++];
}
#+END_SRC
*** Random Behavior Selector
#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_behavior* behave_random(gest_d *g, gest_behavior *b);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_behavior* behave_random(gest_d *g, gest_behavior *b)
{
    gest_metabehavior *mb;

    mb = b->meta;

    return &mb->behaviors[gest_randi(g, mb->size)];
}
#+END_SRC
** Metanodes
Metanodes are ramp tree nodes whose underlying children
can change. A metanode is essentially a monoramp that can
have a fixed number of possibilities within the bounds
of the ramp it takes up. Every time this node gets reached,
it has an opportunity to select one of these possibilities.
*** Struct Declaration
Called =gest_metanode=. Basically an array of pointers to
=gest_node= types.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_metanode gest_metanode;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
struct gest_metanode {
    int pos;
    int size;
    gest_node *parent;
    gest_node **nodes;
};
#+END_SRC
*** Allocation
=metanode_alloc=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_metanode* metanode_alloc(gest_d *g,
                                     gest_node *parent,
                                     int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_metanode* metanode_alloc(gest_d *g,
                                     gest_node *parent,
                                     int sz)
{
    gest_metanode *mn;
    int i;

    mn = gest_alloc(g, sizeof(gest_metanode));
    mn->size = sz;
    mn->pos = 0;
    mn->parent = NULL;
    mn->nodes = gest_alloc(g, sizeof(gest_node *) * sz);

    for (i = 0; i < sz; i++) {
        gest_node *n;

        n = gest_alloc(g, sizeof(gest_node));
        gest_node_init(n);
        n->type = parent->type;
        n->modifier = parent->modifier;
        n->parent = parent;
        n->id = g->nodepos;
        g->nodepos++;
        mn->nodes[i] = n;
    }

    return mn;
}
#+END_SRC
*** Population and the Stack
When a metanode is created, the instance gets pushed onto
the stack.

#+NAME: gest_d
#+BEGIN_SRC c
#define GEST_MNSTACK_SIZE 4
gest_metanode *mnstack[GEST_MNSTACK_SIZE];
int mnpos;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
{
    int i;

    for (i = 0; i < GEST_MNSTACK_SIZE; i++) {
        g->mnstack[i] = NULL;
    }

    g->mnpos = 0;
}
#+END_SRC

The metanode has all traits of a monoramp, with the addition
a non-null metanode struct.

When there is an active metanode, it interrupts the
population of the ramp tree. Normally, tree population
moves left to right with the use of targets. When a target
reaches the end of a node, it goes on to the next
consecutive node. When a metanode is active, the next
node will loop back to the metanode, populating it
until it fills up.


How does gest know when to loop back to the metanode? Well,
it first knows to check when there is a metanode on the
stack.

#+NAME: check_metanode_stack
#+BEGIN_SRC c
if (g->mnpos > 0) {
    gest_metanode *mn;
    metahunt = 1;

    mn = g->mnstack[g->mnpos - 1];

    if (mn != NULL) mnpar = mn->parent;
}
#+END_SRC

A metanode belongs to a monoramp node, and this
address will be known. During the search for the next node,
it will check for this address, and if it finds it, it will
be time to loop back.

#+NAME: check_for_metanode_parent
#+BEGIN_SRC c
if (metahunt && curr == mnpar) {
    <<loopback>>
}
#+END_SRC

A loop-back rewinds the tree to the monoramp contained
residing inside of the metanode. Along the way, it saves
underlying tree it created inside of the metanode, and
resets monoramp to be re-populated again.

#+NAME: loopback
#+BEGIN_SRC c
gest_metanode *mn;
next = curr;
/* store children in metanode */

mn = g->mnstack[g->mnpos - 1];

next = mn->nodes[mn->pos++];

if (mn->pos >= mn->size) {
    g->mnpos--;
    g->mnstack[g->mnpos] = NULL;
    mn->pos = 0;
}

set_curnode(g, next);
break;
#+END_SRC

Monoramps always have exactly one child. This child is
the thing that gets stored.

After storing, the metaramp will check and see if there
are any more slots available. If not, it will pop itself
off the stack.

During performance, Gest is constantly traversing
up and down the Ramp Tree, touching nodes going both ways.
A metanode only changes its underlying children when
it dives downwards to find a target in =dive_to_target=.
*** Sequential Node Selector
#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node* node_seq(gest_d *g, gest_node *n);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_node* node_seq(gest_d *g, gest_node *n)
{
    gest_metanode *mn;

    mn = n->meta;

    if (mn->pos >= mn->size) mn->pos = 0;

    return mn->nodes[mn->pos++];
}
#+END_SRC
*** Random Node Selector
#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node* node_random(gest_d *g, gest_node *n);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_node* node_random(gest_d *g, gest_node *n)
{
    gest_metanode *mn;

    mn = n->meta;

    return mn->nodes[gest_randi(g, mn->size)];
}
#+END_SRC
** Metaphrases
If you've been reading up to this point, you'll no
doubt know what to expect here. A =metaphrase=
is a special phrase containing phrases inside of it.
Every time the phrase gets selected, the metaphrase
gets an opportunity to select one of the phrases.
*** Struct Declaration
Similar to before, a =gest_metaphrase= has a position,
size, and array of phrases. 

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_metaphrase gest_metaphrase;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
struct gest_metaphrase {
    int pos;
    int size;
    gest_phrase *parent;
    gest_phrase **phrases;
};
#+END_SRC
*** Allocation
Allocated with =metaphrase_alloc=. The number of phrases
must be known, as well as the parent phrase.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_metaphrase * metaphrase_alloc(gest_d *g, int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_metaphrase * metaphrase_alloc(gest_d *g, int sz)
{
    gest_metaphrase *mp;
    int i;

    mp = gest_alloc(g, sizeof(gest_metaphrase));
    mp->size = sz;
    mp->pos = 0;
    mp->phrases = gest_alloc(g, sizeof(gest_phrase *) * sz);

    for (i = 0; i < sz; i++) {
        mp->phrases[i] = NULL;
    }

    return mp;
}
#+END_SRC
*** Population and the Stack
Metaphrases are populated via a stack. They can be nested!
This is similar to the constructs that have preceded it.

Populating a metaphrase is similar to making a regular
phrase, except it starts with a different beginning, but
with the same ending.

Phrases get selected during the process when the
next node is found.

#+NAME: gest_d
#+BEGIN_SRC c
#define GEST_MPSTACK_SIZE 4
gest_metaphrase *mpstack[GEST_MPSTACK_SIZE];
int mppos;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
{
    int i;

    for (i = 0; i < GEST_MPSTACK_SIZE; i++) {
        g->mpstack[i] = NULL;
    }

    g->mppos = 0;
}
#+END_SRC

append newly created phrase to last metaphrase on stack.

some fancy footwork below, so pay attention.

appending of the metaphrase happens when a new phrase
is created, but before it is set to be the selected phrase.

if a metaphrase is in play, it will be on the stack. The last
item is peaked at. If the position is all filled up, it means
the newly created phrase is actually the *next* phrase.
Phrases use pointers to indicate the next phrase, so all
the phrases managed by the metaphrase must have their
next pointers explicitely set. The metaphrase is then
popped from the stack. It is also assumed that the currently
selected phrase at this moment is the last phrase of the
metaphrase. This doesn't need to be selected anymore, so
it is cleared.

Most of the time, the metaphrase has phrases to fill. In
this situation, it will append the newly created phrase to
the next available slot in the metaphrase.

#+NAME: append_metaphrase
#+BEGIN_SRC c
if (g->mppos > 0) {
    gest_metaphrase *mp;
    mp = g->mpstack[g->mppos - 1];

    if (mp->pos >= mp->size) {
        int i;

        /* pop from stack */
        g->mppos--;
        g->mpstack[g->mppos] = NULL;

        /* current phrase last phrase in metaphrase, clear it */
        g->phrase_selected = NULL;

        /* all phrases should point to newly made phrase */
        for (i = 0; i < mp->size; i++) {
            mp->phrases[i]->next = phrase;
        }

    } else {
        /* append to next available slot */
        mp->phrases[mp->pos] = phrase;
    }

}
#+END_SRC

#+NAME: metaphrase_next_position
#+BEGIN_SRC c
if (g->mppos > 0) {
    gest_metaphrase *mp;
    mp = g->mpstack[g->mppos - 1];
    mp->pos++;
}
#+END_SRC

#+NAME: metaphrase_loopit
#+BEGIN_SRC c
if (g->mppos > 0) {
    gest_metaphrase *mp;
    mp = g->mpstack[g->mppos - 1];

    if (mp->pos >= mp->size) {
        int i;

        /* pop from stack */
        g->mppos--;
        g->mpstack[g->mppos] = NULL;

        /* current phrase last phrase in metaphrase, clear it */
        g->phrase_selected = NULL;

        /* all phrases should point to newly made phrase */
        for (i = 0; i < mp->size; i++) {
            mp->phrases[i]->next = g->phrase_top;
        }
    }

}
#+END_SRC
*** Sequential Phrase Selector
#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_phrase* phrase_seq(gest_d *g, gest_phrase *ph);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_phrase* phrase_seq(gest_d *g, gest_phrase *ph)
{
    gest_metaphrase *mp;

    mp = ph->meta;

    if (mp->pos >= mp->size) mp->pos = 0;

    return mp->phrases[mp->pos++];
}
#+END_SRC
*** Random Phrase Selector
#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_phrase* phrase_random(gest_d *g, gest_phrase *ph);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_phrase* phrase_random(gest_d *g, gest_phrase *ph)
{
    gest_metaphrase *mp;

    mp = ph->meta;

    return mp->phrases[gest_randi(g, mp->size)];
}
#+END_SRC
* Random Number Generation
Gest implements an internal PRNG using a simple
LCG, similar to many implementations of rand().
This is done to make Gest more consistent across
platforms.

It is (perhaps erroneously) assumed that long integer
values are at least 32-bits long.

#+NAME: gest_d
#+BEGIN_SRC c
unsigned long rng;
#+END_SRC

The initial RNG state can be seeded with =gest_seed=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_seed(gest_d *g, unsigned long rng);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_seed(gest_d *g, unsigned long rng)
{
    g->rng = rng;
}
#+END_SRC

At initializatin, it is seeded with the system =rand=
function. For more consistent results, =gest_seed= can
be explicit called immediately after initialization.

#+NAME: init
#+BEGIN_SRC c
gest_seed(g, rand());
#+END_SRC

A random value is produced with =gest_rand=.

#+NAME: funcdefs
#+BEGIN_SRC c
unsigned long gest_rand(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
unsigned long gest_rand(gest_d *g)
{
    g->rng = (1103515245 * g->rng + 12345) % 2147483648;
    return g->rng;
}
#+END_SRC

A normalized floating point value can be returned with
=gest_randf=.

#+NAME: funcdefs
#+BEGIN_SRC c
SKFLT gest_randf(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
SKFLT gest_randf(gest_d *g)
{
    unsigned long x;

    x = gest_rand(g);

    return (SKFLT)x / 2147483648.0;
}
#+END_SRC

A random integer between 0 and N-1 can be
found with =gest_randi=.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_randi(gest_d *g, int N);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_randi(gest_d *g, int N)
{
    int x;

    x = floor(gest_randf(g) * N);

    if (x >= N) x = N - 1;

    return x;
}
#+END_SRC
* Actions
An action in Gest is an event that can happen when
a new target is selected.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_action gest_action;
#+END_SRC

An action is callback that can have it's own mutable
state attached to it. It is part of a linked list entry,
so it has a =next= pointer as well.

#+NAME: structs
#+BEGIN_SRC c
struct gest_action {
    void (*fun)(gest_d*, void*, int);
    void *data;
    gest_action *next;
};
#+END_SRC

An action lives inside of a list of actions, creatively
referred to as an action list.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_actionlist gest_actionlist;
#+END_SRC

#+NAME: gest_actionlist_struct
#+BEGIN_SRC c
struct gest_actionlist {
    gest_action *head;
    gest_action *tail;
    int sz;
};
#+END_SRC

An actionlist is part of a target.

#+NAME: gest_target
#+BEGIN_SRC c
gest_actionlist lst;
#+END_SRC

#+NAME: gest_target_init
#+BEGIN_SRC c
gest_actionlist_init(&t->lst);
#+END_SRC

An actionlist can be initialized with =gest_actionlist_init=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_actionlist_init(gest_actionlist *lst);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_actionlist_init(gest_actionlist *lst)
{
    lst->head = NULL;
    lst->tail = NULL;
    lst->sz = 0;
}
#+END_SRC

Actions are appended to an action list associated with
a target (usually the actively selected one). This
can be done with the static function =append_action=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void append_action(gest_d *g,
                          gest_target *t,
                          void (*fun)(gest_d*, void*, int),
                          void *data);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void append_action(gest_d *g,
                          gest_target *t,
                          void (*fun)(gest_d*, void*, int),
                          void *data)
{
    gest_action *a;
    gest_actionlist *lst;

    lst = &t->lst;
    a = gest_alloc(g, sizeof(gest_action));

    a->data = data;
    a->fun = fun;
    a->next = NULL;

    if (lst->head == NULL) {
        lst->head = a;
    }

    if (lst->tail != NULL) lst->tail->next = a;
    lst->tail = a;
    lst->sz++;
}
#+END_SRC

A new action requires making a callback, and optionally
some data associated with it. The callback takes in
the instance of gest, the user data associated with
the action, and an integer value representing the current
sample position inside the current render block. This
position can be used for sample-accurate timing.

When a target is set up to be the current target, it
calls the actions inside the action list. This is called
=do_actions=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void do_actions(gest_d *g, gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void do_actions(gest_d *g, gest_target *t)
{
    int pos;
    gest_actionlist *lst;
    gest_action *a;
    int i;

    lst = &t->lst;

    a = lst->head;

    pos = 0; /* TODO: work in later */

    for (i = 0; i < lst->sz; i++) {
        a->fun(g, a->data, pos);
        a = a->next;
    }
}
#+END_SRC
* Scalars
A =scalar= is a mostly constant value that is able
to be changed every time a new target happens. In most
situations, scalars can also change values with
sample accurate timing alongside the target they
are attached to (more on this later).

One good application for scalars are for use as gate
signals when using gest to sequence melody. A target
can change an arbitrary number of scalars, so it is
a good way to add some elementary multi-dimensional
control that is correlated with a gesture.

The data for a scalar is contained in a struct called
=gest_scalar=.

Because it is mostly intended to be used externally from
Gest, the struct is exposed publically in the header.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct {
    SKFLT cur;
    SKFLT nxt;
    int pos;
} gest_scalar;
#+END_SRC

The scalar holds two values, a current value =cur=,
and a next value =nxt=, as well as an integer marking block
position =pos=. When non-negative, the position will mark
at what point in an active audio buffer a value has changed.
Anything before it is the current value, anything on or
after it is the next value.

This struct can be initialized with =gest_scalar_init=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_scalar_init(gest_scalar *s);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_scalar_init(gest_scalar *s)
{
    s->cur = 0;
    s->nxt = 0;
    s->pos = -1;
}
#+END_SRC

The current/next value approach with a position flag allows
for up to one change to happen inside of a audio block. In
patchwerk, this is typically a block size of 64 samples.
This means targets cannot be spaced less thans than 1ms
apart. For most situations, this is an acceptable
limitation. As a result, what is achieved is a very
efficient means for sample accurate timing.

#+NAME: static_funcdefs
#+BEGIN_SRC c
#+END_SRC

Scalars are external to an instance of gest, and are
connected to it via an action.

The function =action_scalar= creates a new action for
a target that sets the input scalar to a particular value.
The action will set the next value of the scalar, and set
the position.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void action_scalar(gest_d *g,
                          gest_target *t,
                          gest_scalar *s,
                          SKFLT val);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
struct action_scalar_d {
   gest_scalar *s;
   SKFLT val;
};

static void scalar_cb(gest_d *g, void *ud, int pos)
{
    struct action_scalar_d *ad;
    ad = (struct action_scalar_d *)ud;

    ad->s->nxt = ad->val;
    ad->s->pos = pos;
}

static void action_scalar(gest_d *g,
                          gest_target *t,
                          gest_scalar *s,
                          SKFLT val)
{
    struct action_scalar_d *ad;

    ad = gest_alloc(g, sizeof(struct action_scalar_d));

    ad->s = s;
    ad->val = val;

    append_action(g, t, scalar_cb, ad);
}
#+END_SRC

In order for scalar logic to work properly, the instance of
Gest must be computed before the scalar value is computed.
That way, the scalar value gets updated properly.

The scalar node itself is beyond the scope of this document,
but an implementation of a scalar node using sndkit is
available in this project.
