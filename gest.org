#+TITLE:Gest
* Overview
Gest is a sequencer for gesture.

Gest lies somewhere between a classical step sequencer and
an automation curve generator. The goal of Gest is to be a
better LFO.

To understand how Gest works, a few terms will be described.

Gest synthesizes =Gestures=: audio-rate control signals
intended to be mapped to parameters of other unit
generators in a modular synthesis environment. The overall
goal of Gest is to be able to use it as a way to add more
layers of nuance to computer-performed music, in
particular, lyrical music.

Similar to a step sequencer, Gest is clocked by an exernal
signal, known as a =conductor= signal. This signal is
expected to be a =phasor= signal, a periodic rising ramp
signal going from 0 to 1. Once instantiated with a
conductor signal, Gest can then be programmed to perform
Gestures.

A phasor is a continuous timing source. Not only does it
mark out pacing, but also position within a beat. Every
full ramp from 0 to 1 is a period, referred to as a =beat=
of time.

Gestures are created in sequences of chunks. A single chunk
is known as a =phrase=. A phrase takes up duration measured
in beats from the conductor signal. The phrase analyzes the
conductor, and resynthesizes a new slower signal: a single
ramp going from 0 to 1 spannign the whole duration of the
phrase. This signal is called a =monoramp=. The monoramp
acts a blank canvas to make rhythms with. A monoramp can be
equally divided up into an arbitray number of smaller
ramps, known as a =polyramp=. Contiguous ramps in a
polyramp can be fused backtogether in monoramps, and then
more polyramps can be made from those. This builds a tree
hierarchy of ramps with various subdivisions, known as a
=ramp tree=.

The end leaves of the Ramp Tree are capped with what is
known as a =target=. A target is a scalar value. Using the
ramps from the Ramp Tree, consecutive targets are
interpolated together to generate a contiguous line
segment. The way segments travel from target A to B is
known as a =behavior=. Behaviors can be any number of
things, including linear, exponential, or step.
* Tangled Files
=gest.c= and =gest.h=.

Defining =GEST_PRIVATE= will expose the core gest struct.

#+NAME: gest.h
#+BEGIN_SRC c :tangle gest.h
#ifndef GEST_H
#define GEST_H

#ifndef SKFLT
#define SKFLT float
#endif

<<typedefs>>

#ifdef GEST_PRIVATE
<<structs>>
#endif

<<funcdefs>>
#endif
#+END_SRC

#+NAME: gest.c
#+BEGIN_SRC c :tangle gest.c
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#define GEST_PRIVATE
#include "gest.h"
<<enums>>
<<static_funcdefs>>
<<funcs>>
#+END_SRC
* Core Struct
** Struct Declaration(s)
All data for instance of gest is managed in a struct
called =gest_d=. It is initialized with =gest_init=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_d gest_d;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
<<gest_target>>
<<struct_ramptree>>
<<struct_phrase>>
<<struct_collection>>
<<gest_state>>
struct gest_d {
    <<gest_d>>
};
#+END_SRC
** Initialization
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_init(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_init(gest_d *g)
{
    <<init>>
}
#+END_SRC
** Cleanup
Fully clean up things with =gest_cleanup=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_cleanup(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_cleanup(gest_d *g)
{
    <<cleanup>>
}
#+END_SRC
** Sizeof
=gest_sizeof= is used for opaque functions.

#+NAME: funcdefs
#+BEGIN_SRC c
size_t gest_sizeof(void);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
size_t gest_sizeof(void)
{
    return sizeof(gest_d);
}
#+END_SRC
* Components
** Conductor Analysis Components
#+NAME: gest_d
#+BEGIN_SRC c
SKFLT last;
SKFLT last_inc;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->last = 0;
g->last_inc = 0;
#+END_SRC

When the previous sample is larger
than the current sample, it is registered as a reset, and
the reset flag is set.
** Phase
#+NAME: gest_d
#+BEGIN_SRC c
SKFLT phs;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->phs = -1;
#+END_SRC
** Top/Selected Target and Cached Values
This is called =curtarget=.

The top target from the first phrase is stored
in a variable called =toptarget=. This is used
so the last target of the last phrase can smoothly
loop back to the top.

#+NAME: gest_d
#+BEGIN_SRC c
gest_target *curtarget;
gest_target *toptarget;
gest_target *nxttarget;
int targetondeck;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->curtarget = NULL;
g->toptarget = NULL;
g->nxttarget = NULL;
g->targetondeck = 0;
#+END_SRC

Value for the current and next targets are cached
for faster accessibility.

#+NAME: gest_d
#+BEGIN_SRC c
SKFLT curval;
SKFLT nxtval;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->curval = 0;
g->nxtval = 0;
#+END_SRC

Update the current target with =set_curtarget=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void set_curtarget(gest_d *g, gest_target *target);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void set_curtarget(gest_d *g, gest_target *target)
{
    g->curtarget = target;
    g->curval = target->value;
    apply_weight(g, target);
}
#+END_SRC


#+NAME: funcdefs
#+BEGIN_SRC c
gest_target * gest_curtarget(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
gest_target * gest_curtarget(gest_d *g)
{
    return g->curtarget;
}
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
gest_target * gest_nxttarget(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
gest_target * gest_nxttarget(gest_d *g)
{
    return g->nxttarget;
}
#+END_SRC
** Stack
Tree nodes create a new layer every time it descends into
children nodes. This is managed with a stack containing the
parent node and current state. When a node begins, it
pushes itself onto the stack, and pops itself off when it
ends.
** Modifier
The modifier is a value which mainpulates the increment
value calculated from the analyzing the conductor signal.

It is represented as a rational value with a numerator and
denominator, represented as integers.

#+NAME: gest_d
#+BEGIN_SRC c
int num;
int den;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->num = 1;
g->den = 1;
#+END_SRC

Monoramps manipulate
the numerator, increasing the increment value by a factor
and slowing it down. Polyramps manpulate the denominator,
decreasing the increment amount and speeding it up.
** Top/Selected Phrases
Gestures are created in units of phrases, so a few
variable references are stored here.

For starters, the starting phrase is stored in a variable
called =phrase_top=. It is expected that the gesture will
iterate in a (mostly) linear fashion as a linked list.

When populating and computing gest, the currently
selected phrase is stored in a variable called
=phrase_selected=.

#+NAME: gest_d
#+BEGIN_SRC c
gest_phrase *phrase_top;
gest_phrase *phrase_selected;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->phrase_top = NULL;
g->phrase_selected = NULL;
#+END_SRC
** Collection
A local instance of a =gest_collection=, used to allocate
components needed to make gestures.

#+NAME: gest_d
#+BEGIN_SRC c
gest_collection col;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
collection_init(&g->col);
#+END_SRC

#+NAME: cleanup
#+BEGIN_SRC c
collection_cleanup(&g->col);
#+END_SRC
** Selected Ramp Tree Node
A copy of the currently selected ramp tree node
is stored in a variable called =curnode=.

#+NAME: gest_d
#+BEGIN_SRC c
gest_node *curnode;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->curnode = NULL;
#+END_SRC

select it with =set_curnode=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void set_curnode(gest_d *g, gest_node *node);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void set_curnode(gest_d *g, gest_node *node)
{
    g->curnode = node;
}
#+END_SRC

The next node is also stored as well. Will be needed moving
forward, in order for things like metatargets to work.

#+NAME: gest_d
#+BEGIN_SRC c
gest_node *nxtnode;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->nxtnode = NULL;
#+END_SRC
** Node Position
Needed for debugging.

#+NAME: gest_d
#+BEGIN_SRC c
int nodepos;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->nodepos = 0;
#+END_SRC
** Global Temporal Inertia and Mass
The global inertia and mass amounts used for
temporal weight.

Targets in Gest can manipulate the external conductor
signal, causing temporal fluctuations. Tempo can be
slowed down or sped up by changing the mass. The
rate at which the changes happen is measured with
inertia.

#+NAME: gest_d
#+BEGIN_SRC c
SKFLT inertia;
SKFLT mass;
#+END_SRC

By default, the mass is set to be regular (0) with
instantaneous inertia (0).

#+NAME: init
#+BEGIN_SRC c
g->inertia = 0;
g->mass = 0;
#+END_SRC

Getters are =gest_mass_get= and =gest_inertia_get=.

#+NAME: funcdefs
#+BEGIN_SRC c
SKFLT gest_mass_get(gest_d *g);
SKFLT gest_inertia_get(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
SKFLT gest_mass_get(gest_d *g)
{
    return g->mass;
}

SKFLT gest_inertia_get(gest_d *g)
{
    return g->inertia;
}
#+END_SRC
** Position In Time
Used for clock drift compensation.
Measured in beats, and with an accumulator.

#+NAME: gest_d
#+BEGIN_SRC c
int beat;
SKFLT t;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->beat = 0;
g->t = 0;
#+END_SRC
** Please Wait Flag
#+NAME: gest_d
#+BEGIN_SRC c
int please_wait;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->please_wait = 0;
#+END_SRC
** Correction
#+NAME: gest_d
#+BEGIN_SRC c
SKFLT correction;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->correction = 1.0;
#+END_SRC
** User Data
#+NAME: gest_d
#+BEGIN_SRC c
void *ud;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->ud = NULL;
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_data_set(gest_d *g, void *ud);
void * gest_data_get(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_data_set(gest_d *g, void *ud)
{
    g->ud = ud;
}

void * gest_data_get(gest_d *g)
{
    return g->ud;
}
#+END_SRC
** Previous Output Value
The =prevout= variable caches the output of the
previously computed sample. This is useful for
situations when gest gets paused mid-gesture.

#+NAME: gest_d
#+BEGIN_SRC c
SKFLT prevout;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
g->prevout = 0;
#+END_SRC
** TODO next target state
The variable =nxtstate= stores the state information
needed for the next node.

#+NAME: gest_d
#+BEGIN_SRC c
gest_state nxtstate;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
init_state(&g->nxtstate);
#+END_SRC

Metatargets change things up. Before metatargets,
it used to be that targets were things that wouldn't
change, and this made logic and flow very simpler.
Metatargets can change their targets. Because of this,
there is a need to introduce cached states.

Basically, when the next target is acquired, it takes
a snapshot of that state, which can then be applied
without any traversal or searching.

State is represetned by the struct =gest_state=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_state gest_state;
#+END_SRC

State includes the target, the node belonging to
that target, the modifier (representation as rational
value with numerator/denominator integers), and the phrase.

#+NAME: gest_state
#+BEGIN_SRC c
struct gest_state {
    gest_target *target;
    gest_node *node;
    gest_phrase *phrase;
    int num;
    int den;
};
#+END_SRC

Initialize state with =init_state=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void init_state(gest_state *s);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void init_state(gest_state *s)
{
    s->num = 1;
    s->den = 1;
    s->phrase = NULL;
    s->target = NULL;
    s->node = NULL;
}
#+END_SRC
* Core Commands
Some core commands for programming.
** Begin
Begin: begins a phrase. Takes in duration (in beats) as an
argument.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_begin(gest_d *g, int beats, int div);
#+END_SRC

The begin command creates and initializes a new phrase,
which then gets appended to the last phrase.

The first phrase to get created becomes the beginning
phrase in gest.

#+NAME: funcs
#+BEGIN_SRC c
void gest_begin(gest_d *g, int beats, int div)
{
    gest_phrase *phrase;

    phrase = gest_alloc(g, sizeof(gest_phrase));

    phrase_init(g, phrase, beats, div);

    if (g->phrase_top == NULL) {
        g->phrase_top = phrase;
    }

    if (g->phrase_selected != NULL) {
        g->phrase_selected->next = phrase;
    }

    g->phrase_selected = phrase;

    /* TODO make this a targetondeck flag */
    set_curnode(g, g->phrase_selected->top);
}
#+END_SRC
** End
End: closes out the phrase. If the phrase isn't fully
completed a non-zero value is returned.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_end(gest_d *g);
#+END_SRC

Error checking is done by examining the top-level polyramp
in the currently selected phrase. A completed phrase will
have every child node capped with a target.

#+NAME: funcs
#+BEGIN_SRC c
int gest_end(gest_d *g)
{
    int count;
    gest_node *top;

    top = g->phrase_selected->top;

    count = node_count(top, NULL);

    if (count != top->modifier) return 1;

    return 0;
}
#+END_SRC
** Polyramp
Polyramp: Takes the current ramp, and divides it up into N
beats.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_polyramp(gest_d *g, int div);
#+END_SRC

When a new polyramp node is made, it's node becomes
the actively selected node to be populated. If something
goes wrong, an non-zero error value is returned/

#+NAME: funcs
#+BEGIN_SRC c
int gest_polyramp(gest_d *g, int div)
{
    gest_node *n;

    n = mkpolyramp(g, g->curnode, div);

    if (n == NULL) {
        return 1;
    }

    set_curnode(g, n);

    return 0;
}
#+END_SRC
** Monoramp
Monoramp: Produces a monoramp that takes up N beats.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_monoramp(gest_d *g, int nbeats);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_monoramp(gest_d *g, int nbeats)
{
    gest_node *n;

    n = mkmonoramp(g, g->curnode, nbeats);

    if (n == NULL) {
        return 1;
    }

    set_curnode(g, n);

    return 0;
}
#+END_SRC
** Addtarget
Target: Caps the current ramp with a scalar target, as a
floating point value. uses linear behavior by default.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_addtarget(gest_d *g, SKFLT val);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int gest_addtarget(gest_d *g, SKFLT val)
{
    gest_target *t;

    t = mktarget(g);

    if (t == NULL) {
        return 1;
    }

    if (g->toptarget == NULL) {
        g->toptarget = t;
    }

    if (g->curtarget != NULL) {
        g->curtarget->next = t;
    }

    g->curtarget = t;
    t->value = val;
    gest_behavior_linear(g);

    return 0;
}
#+END_SRC
** Finish
The finish command =gest_finish= completes population
and initializes gest to start at the top.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_finish(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_finish(gest_d *g)
{
    gest_node *top;

    g->den = 1;
    g->num = 1;

    g->phrase_selected = g->phrase_top;

    top = dive_to_target(g, g->phrase_top->top);

    set_curnode(g, top);
    set_curtarget(g, node_target(top));

    init_state(&g->nxtstate);
    find_next_node(g, g->curnode, &g->nxtstate);
    g->nxttarget = g->nxtstate.target;

    if (g->nxttarget != NULL) {
        g->nxtval = g->nxttarget->value;
    } else {
        g->nxtval = g->curval;
    }
}
#+END_SRC
** Loopit
The command =gest_loopit= will loop the current phrase back
to the beginning phrase.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_loopit(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_loopit(gest_d *g)
{
    g->curtarget->next = g->toptarget;
    g->phrase_selected->next = g->phrase_top;
}
#+END_SRC
** Addmetatarget
The function =gest_addmetatarget= will create a new
metatarget with a size of =sz= metatargets.

#+NAME: funcdefs
#+BEGIN_SRC c
int gest_addmetatarget(gest_d *g, int sz);
#+END_SRC

This function will implicitely create a new target
using =gest_addtarget=, then configure this
target to be a metatarget.

After it is created, the metatarget gets pushed onto the
metatarget stack contained in the gest data.

#+NAME: funcs
#+BEGIN_SRC c
int gest_addmetatarget(gest_d *g, int sz)
{
    int rc;
    gest_target *t;
    gest_metatarget *mt;

    if (g->mtpos >= GEST_MTSTACK_SIZE) return 2;

    rc = gest_addtarget(g, -1);

    if (rc) return rc;

    t = g->curtarget;

    mt = metatarget_alloc(g, sz);

    t->get = get_seq;
    t->meta = mt;

    /* push to stack */
    g->mtstack[g->mtpos++] = mt;
    return 0;
}
#+END_SRC
* Behavior Commands
Behaviors are the means by which one target gets to thep
next target.
** Linear
Linear: converts the last target to use linear behavior.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_linear(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT linear(gest_d *g, SKFLT a, void *ud)
{
    return a;
}

void gest_behavior_linear(gest_d *g)
{
    g->curtarget->tick = linear;
}
#+END_SRC
** Step
Step: converts the last target to be a step (no line, just
the value).

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_step(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT step(gest_d *g, SKFLT a, void *ud)
{
    return 0;
}

void gest_behavior_step(gest_d *g)
{
    g->curtarget->tick = step;
}
#+END_SRC
** Gliss
=Gliss= is a behavior intended
gestures that are pitches mimicking glissando.
It works by cutting the incoming ramp in half. The
first half is 0, and the second half gets
normalized to be 0-1 with a cubic slope. This
then gets interpolated between the x and y target
values.
*** Regular Gliss
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_gliss(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT gliss(gest_d *g, SKFLT a, void *ud)
{
    if (a < 0.5) {
        a = 0;
    } else {
        a -= 0.5;
        if (a < 0) a = 0;
        a *= 2;
        a = a * a * a;
    }

    return a;
}

void gest_behavior_gliss(gest_d *g)
{
    g->curtarget->tick = gliss;
}
#+END_SRC
*** Small Gliss
=smallgliss= does this, but smaller scale. Best for
instruments that want the minimal amount of smoothing
done to preserve a step-sequenced sound.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_smallgliss(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT smallgliss(gest_d *g, SKFLT a, void *ud)
{
    if (a < 0.97) {
        a = 0;
    } else {
        a -= 0.97;
        if (a < 0) a = 0;
        a /= 0.03;
        a = a * a * a;
    }
    return a;
}

void gest_behavior_smallgliss(gest_d *g)
{
    g->curtarget->tick = smallgliss;
}
#+END_SRC
*** Medium Gliss
Ideally tuned for voice.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_mediumgliss(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT mediumgliss(gest_d *g, SKFLT a, void *ud)
{
    if (a < 0.75) {
        a = 0;
    } else {
        a -= 0.75;
        if (a < 0) a = 0;
        a /= 0.25;
        a = a * a * a;
    }
    return a;
}

void gest_behavior_mediumgliss(gest_d *g)
{
    g->curtarget->tick = mediumgliss;
}
#+END_SRC
** Exponential
Exponential: converts the last target to use exponential
behavior with slope =slope=.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_exponential(gest_d *g, SKFLT slope);
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_step(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT exponential(gest_d *g, SKFLT a, void *ud)
{
    SKFLT *s;

    s = ud;

    return (1.0 - exp(a * (*s))) / (1 - exp(*s));
}

void gest_behavior_exponential(gest_d *g, SKFLT slope)
{
    SKFLT *s;
    g->curtarget->tick = exponential;
    g->curtarget->aux = gest_alloc(g, sizeof(SKFLT));
    s = (SKFLT *)g->curtarget->aux;
    *s = slope;
}
#+END_SRC
** Bezier
Applies a quadratic Bezier line segment between to two
targets. Bezier takes in two control values that are
control targets.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_behavior_bezier(gest_d *g, SKFLT cx, SKFLT cy);
#+END_SRC

Explanation for how this works is already done in
the sndkit Bezier algorithm where this is
code is based, so it's worth checking
that out for the mathematical derivation.

#+NAME: funcs
#+BEGIN_SRC c
struct bezier_data {
    SKFLT cx;
    SKFLT cy;
};

/* https://pbat.ch/sndkit/bezier/ */

static SKFLT quadratic_equation(SKFLT a, SKFLT b, SKFLT c)
{
    SKFLT det; /* determinant */

    det = b*b - 4*a*c;

    if (det >= 0) {
        return ((-b + sqrt(det))/(2.0*a));
    } else {
        return 0;
    }
}

static SKFLT find_t(SKFLT x0, SKFLT x1, SKFLT x2, SKFLT x)
{
    SKFLT a, b, c;

    a = (x0 - 2.0 * x1 + x2);
    b = 2.0 * (-x0 + x1);
    c = x0 - x;

    if (a) {
        return quadratic_equation(a, b, c);
    } else {
        return (x - x0) / b;
    }
}

static SKFLT bezier_curve(SKFLT xpos, SKFLT cx, SKFLT cy)
{
    SKFLT x[3];
    SKFLT y[3];
    SKFLT t;
    SKFLT val;

    x[0] = 0;
    x[1] = cx;
    x[2] = 1;

    y[0] = 0;
    y[1] = cy;
    y[2] = 1;

    t = find_t(x[0], x[1], x[2], xpos);

    val = (1.0-t)*(1.0-t)*y[0] + 2.0*(1 - t)*t*y[1] + t*t*y[2];
    return val;
}

static SKFLT bezier(gest_d *g, SKFLT a, void *ud)
{

    struct bezier_data *bd;
    bd = ud;
    return bezier_curve(a, bd->cx, bd->cy);
}

void gest_behavior_bezier(gest_d *g, SKFLT cx, SKFLT cy)
{
    struct bezier_data *bd;
    g->curtarget->tick = bezier;
    g->curtarget->aux = gest_alloc(g, sizeof(struct bezier_data));
    bd = (struct bezier_data *)g->curtarget->aux;
    bd->cx = cx;
    bd->cy = cy;
}
#+END_SRC
* Temporal Weight Commands
** mass
=gest_mass= the global mass to an absolute value.
Should be in range -120 to 120. 120 is a number chosen
for it's divisibility properties.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_mass(gest_d *g, SKFLT mass);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_mass(gest_d *g, SKFLT mass)
{
    gest_target *t;

    t = g->curtarget;

    t->mass = mass;
    t->mass_mode = WEIGHT_ABSOLUTE;
}
#+END_SRC
** inertia
=gest_inertia= sets the inertia to be a absolute value.

#+NAME: funcdefs
#+BEGIN_SRC c
void gest_inertia(gest_d *g, SKFLT inertia);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_inertia(gest_d *g, SKFLT inertia)
{
    gest_target *t;

    t = g->curtarget;

    t->inertia = inertia;
    t->inertia_mode = WEIGHT_ABSOLUTE;
}
#+END_SRC
** TODO shrink/grow
=gest_shrink= and =gest_grow= cause the mass to shrink
and grow by a percentage value.
** TODO speedup/slowdown
=gest_speedup= and =gest_slowdown= cause the inertia
to grow or shrink by a certain amount.
* Phrases
A gesture is built of out of chunks known as as a =phrase=.
Phrases convert an incoming conductor signal into a single
monoramp, and then divide that monoramp into a polyramp.
** Struct Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_phrase gest_phrase;
#+END_SRC

#+NAME: struct_phrase
#+BEGIN_SRC c
struct gest_phrase {
    gest_node *top;
    SKFLT mod;
    int beats;
    gest_phrase *next;
};
#+END_SRC

The phrase forms the top of a Ramp Tree that gets populated.

When a phrase is over, it points to the next phrase. If
there is no phrase, it loops back to itself.
** Initialization
A phrase gets initialized with =phrase_init=. The duration
of the phrase, measured in beats, is supplied.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void phrase_init(gest_d *g,
                        gest_phrase *phrase,
                        int beats,
                        int div);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void phrase_init(gest_d *g,
                        gest_phrase *phrase,
                        int beats,
                        int div)
{
    phrase->mod = 1.0 / beats;
    phrase->beats = beats;
    phrase->next = NULL;
    phrase->top = mkpolyramp(g, NULL, div);
}
#+END_SRC
* Ramp Tree
** The Ramp Tree Struct
*** Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_node gest_node;
#+END_SRC

#+NAME: struct_ramptree
#+BEGIN_SRC c
struct gest_node {
    <<gest_node>>
};
#+END_SRC

The Ramp Tree is a hierarchical tree data structure.
Nodes on the tree are contained in a struct known as
a =gest_node=. It is initialized with =gest_node_init=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void gest_node_init(gest_node *n);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void gest_node_init(gest_node *n)
{
    <<gest_node_init>>
}
#+END_SRC
*** Node Type (type)
The node =type= indicates whether or not is a =polyramp= or
a =monoramp=. By default, it is a null node.

#+NAME: gest_node
#+BEGIN_SRC c
int type;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->type = NODE_NOTHING;
#+END_SRC

#+NAME: enums
#+BEGIN_SRC c
enum  {
    NODE_NOTHING,
    NODE_POLYRAMP,
    NODE_MONORAMP
};
#+END_SRC
*** Modifier (modifier)
The =modifier= is a integer amount used to rescale the
incoming ramp signal.

#+NAME: gest_node
#+BEGIN_SRC c
int modifier;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->modifier = NODE_NOTHING;
#+END_SRC
*** Number of Children (nchildren)
The number of children a node has is stored by a variable
=nchildren=. The children nodes are stored in =children=
as a linked list, using the =next= entry.

#+NAME: gest_node
#+BEGIN_SRC c
int nchildren;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->nchildren = 0;
#+END_SRC
*** Children Nodes
The actual children of a particular node is contained
in a linked list (using the node itself as an entry point).
The node only stores the head of the list.

#+NAME: gest_node
#+BEGIN_SRC c
gest_node *children;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->children = NULL;
#+END_SRC
*** Node Target Value (target)
Every node can carry a =target=, though only leaves of
the tree can have targets. This value is otherwise left
empty.

#+NAME: gest_node
#+BEGIN_SRC c
gest_target *target;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->target = NULL;
#+END_SRC
*** Next Node in List (next)
Contiguous nodes that are children to a parent node are
linked together in a linked list, with each node
pointing to the next with a variable called =next=.

#+NAME: gest_node
#+BEGIN_SRC c
gest_node *next;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->next = NULL;
#+END_SRC
*** Parent Node (parent)
A pointer to the parent node is a way for nodes
to keep track of position while traversing or
populating the tree.

#+NAME: gest_node
#+BEGIN_SRC c
gest_node *parent;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->parent = NULL;
#+END_SRC
*** Node ID
used for debugging.
#+NAME: gest_node
#+BEGIN_SRC c
int id;
#+END_SRC

#+NAME: gest_node_init
#+BEGIN_SRC c
n->id = -1;
#+END_SRC
** Global Modifier Manipulation
The Ramp Tree manipulates the
underlying rephasor signal by manipulating the incrementor
value through multiplication or division.

Iteration through a node works slightly differently
depending on if it is a monoramp or a polyramp. A monoramp
keeps track of time from the input signal before finishing.
A polyramp keeps track of time using it's own synthesized
signal. Polyramps iterate through their children nodes,
which can recrusively call more monoramps and polyramps.

Every sample, the Tree Ramp moves forward in time and
computes a value. This value is fed into the current target
callback.

Nodes in the ramptree count. So, I guess some kind of
counter? We will use a counter and a limit, that way the
node can be reset multiple times. Every node updates it's
counter when it detects a reset.
** Populating a tree with nodes
The general concept populating a tree is that nodes are
created, then more nodes are created that become children
of the previous nodes. Population of a tree works from left
to right.

Creating a node is not only allocating a node, but also
appending it to be a child of the parent node. This
means all nodes need to have their parent present.

Linking the new node to the parent node is a matter of
appending to the end of the =children= list.
*** Creating a new polyramp node
A polyramp node is a node that takes one monoramp and
subdivides it into a fixed number of ramps. Each of
those ramps can be a potential child node.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node * mkpolyramp(gest_d *g,
                              gest_node *parent,
                              int div);
#+END_SRC

The new node is linked to the parent node by appending it
to the end of the child list. Before this happens, a quick
check is done to make sure the parent node isn't already
full.

#+NAME: funcs
#+BEGIN_SRC c
static gest_node * mkpolyramp(gest_d *g,
                              gest_node *parent,
                              int div)
{
    gest_node *n, *last;
    int total;

    /* check to see if parent node is full */

    total = 0;
    last = NULL;

    if (parent != NULL) {
        total = node_count(parent, &last);
        if (total >= parent->modifier) {
            return NULL;
        }
    }

    n = gest_alloc(g, sizeof(gest_node));
    gest_node_init(n);
    n->type = NODE_POLYRAMP;
    n->modifier = div;
    n->parent = parent;
    n->id = g->nodepos;
    g->nodepos++;

    if (parent != NULL) {
        append_node(parent, n, last);
    }

    if (parent == NULL) {
        n->parent = n;
    }

    return n;
}
#+END_SRC
*** Creating a new monoramp node
A monoramp node takes a contiguous set of children from
a polyramp node and merges them together into one ramp.
A monoramp can have only one potential child node.

The monoramp takes in the number of input ramp periods
it will span. It will verify there is enough room in the
parent node before creating.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node * mkmonoramp(gest_d *g,
                              gest_node *parent,
                              int ninputs);
#+END_SRC

Similar to =mkpolyramp=, the parent node is checked for
room.

#+NAME: funcs
#+BEGIN_SRC c
static gest_node * mkmonoramp(gest_d *g,
                              gest_node *parent,
                              int ninputs)
{
    gest_node *n, *last;
    int total;

    last = NULL;

    if (parent != NULL) {
        total = node_count(parent, &last);
        total += ninputs;
        if (total > parent->modifier) return NULL;
    }

    n = gest_alloc(g, sizeof(gest_node));
    gest_node_init(n);
    n->type = NODE_MONORAMP;
    n->modifier = ninputs;
    n->parent = parent;
    n->id = g->nodepos;
    g->nodepos++;

    if (parent != NULL) {
        append_node(parent, n, last);
    }

    return n;
}
#+END_SRC
** Some Ramp Tree Functions
*** Node Count
=node_count= counts the number of children in a node.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int node_count(gest_node *node, gest_node **last);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int node_count(gest_node *node, gest_node **last)
{
    int total;
    int i;
    gest_node *child;

    total = 0;

    if (node == NULL) {
        return -1;
    }

    child = node->children;

    for (i = 0; i < node->nchildren; i++) {
        if (child->type == NODE_MONORAMP) {
            /* monoramps eat up M ramps */
            total += child->modifier;
        } else if (child->type == NODE_POLYRAMP) {
            /* polyramps always occupy one ramp */
            total++;
        }

        if (last != NULL && i == node->nchildren - 1) {
            *last = child;
        }

        child = child->next;
    }

    return total;
}
#+END_SRC
*** Append Node to Parent
Append a node to a parent node with =append_node=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void append_node(gest_node *parent,
                        gest_node *node,
                        gest_node *last);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void append_node(gest_node *parent,
                        gest_node *node,
                        gest_node *last)
{
    if (last == NULL) {
        parent->children = node;
    } else {
        last->next = node;
    }

    parent->nchildren++;
}
#+END_SRC
*** Dive To Target
Dive into node tree until next target is found.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_node * dive_to_target(gest_d *g,
                                  gest_node *node);
#+END_SRC

A special edge case is handled when target node is
a monoramp with a modifier greater than 1. It will
be explicitely applied before being returned.
The correspdoning reverting happens in =mktarget=
before the next target is set.

#+NAME: funcs
#+BEGIN_SRC c
static gest_node * dive_to_target(gest_d *g,
                                  gest_node *node)
{
    if (node->target != NULL) {
        apply_modifier(g, node);
        return node;
    }


    while (node->target == NULL) {
        apply_modifier(g, node);

        /* go to left-most child */
        node = node->children;
        if (node == NULL) break;
    }

    if (node->type == NODE_MONORAMP && node->modifier > 1) {
        apply_modifier(g, node);
    }

    return node;
}
#+END_SRC
*** Revert/Apply Modifiers
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void revert_modifier(gest_d *g, gest_node *node);
static void apply_modifier(gest_d *g, gest_node *node);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void revert_modifier(gest_d *g, gest_node *node)
{
    if (node->type == NODE_POLYRAMP) {
        g->num /= node->modifier;
    } else if (node->type == NODE_MONORAMP) {
        g->den /= node->modifier;
    }
}
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void apply_modifier(gest_d *g, gest_node *node)
{
    if (node->type == NODE_POLYRAMP) {
        g->num *= node->modifier;
    } else if (node->type == NODE_MONORAMP) {
        g->den *= node->modifier;
    }
}
#+END_SRC
** Target Getter
The function =node_target= is used to get
the target associated with a node. This layer
of abstraction is needed for metatargets.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_target *node_target(gest_node *node);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_target *node_target(gest_node *node)
{
    gest_target *t;

    if (node == NULL) return NULL;

    t = node->target;

    if (node->target != NULL && node->target->get != NULL) {
        while (1) {
            t = t->get(node, t);
            if (t->meta == NULL) break;
        }
    }

    return t;
}
#+END_SRC
* Stepping Through The Ramp Tree
A big part of gest involves stepping through a ramp tree.
A ramp tree produces a set of normalized ramp values
from 0 to 1, whose period lengths are proportional
to the external conductor signal. These values
can then be used to interpolate between targets.

The ramp tree value is computed with =ramptree_step=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset)
{
    SKFLT out;
    SKFLT phs;

    out = 0;

    phs = g->phs;

    if (g->phrase_selected == NULL) return phs;

    <<beat_checkin>>

    inc *= g->phrase_selected->mod * g->correction;

    <<set_the_output>>
    <<update_targets>>
    <<update_phase>>
    <<check_and_update>>

    g->phs = phs;
    g->t += inc;

    return out;
}
#+END_SRC
** Beat Check-in
In order to combat clock drift, a phrase "checks in" every
time conductor signal resets, which is an indicator of the
new beat. Every time a new beat occurs, the status of the
phrase is figured out, and handled accordingly.

Clock drift naturally occurs within Gest because it
resynthesizes a new timing signal based on the external
conductor signal. Left unchecked, Gestures will eventually
fall out of time with the conductor due to the fact that
they are marching to the beat of their own drum.

The coarse way that clock drift is managed is by keeping
drift localized within the phrase. A phrase is allocated
to be a fixed number of beats. When the conductor goes
on to the next beat, the current phrase, wherever it may
be in its performance, is discarded, and the clock drift
debt is reset.

Gestures are a game of constant imprecision. Their timing
can either be late or early, but never quite on time.
Early gestures occur when a
phrase finishes before the conductor. When this happens, it
is told to wait, returning 1 until the first downbeat of the
next phrase. Late
phrases don't quite make it to the end of their gesture.
When this happens, the phrase bails and jumps to the next
one. The hope is that they are close enough to prevent an
audible glitch.

During the check-in, the ideal position, obtained from
the beat counter and known as the =goal=,
can be compared with the actual position =t=. These two
values can be used to create a course correction factor,
which allows the gesture to slow down or speed up to more
closely match the conductor signal.

#+NAME: beat_checkin
#+BEGIN_SRC c
if (reset) {
    int limit;
    SKFLT goal;

    limit = g->phrase_selected->beats;
    g->beat++;
    goal = (SKFLT) g->beat / limit;

    if (g->t > 0) g->correction = goal / g->t;

    if (g->beat >= limit) {
        g->beat = 0;
        g->t = 0;
        g->phs = 0;
        g->please_wait = 0;
        g->correction = 1.0;
        g->targetondeck = 1;
        g->phrase_selected = g->nxtstate.phrase;
        return phs;
    }
} else if (g->please_wait) {
    return 1.0;
}
#+END_SRC
** Setting the Output
The point of this function is to update the overall state of
the ramp trees in gest and return a corresponding ramp
value.

The returned value is the computation done on the previous
call to =ramptree_step=.

#+NAME: set_the_output
#+BEGIN_SRC c
out = g->phs;
#+END_SRC
** Updating Targets
A set =targetondeck= flag will not only be
used to change the target, but also the state information
that comes with the target, such as the node, the phrase,
and the conductor modifier associated with the target.

It is also here that the next node is found. Information
for the next node needs to be immediately available, as
certain tools using and extending gest (such as the vocal
tract interpolation work) rely on knowing about
the next target for it to work properly.

It is assumed that by the time =targetondeck= is found,
the next node is already in place (presumably
from the last time targetondeck was set, or initialization),
and just needs to be swapped in.

#+NAME: update_targets
#+BEGIN_SRC c
if (g->targetondeck) {
    gest_state *s;
    int shouldiwait;

    s = &g->nxtstate;

    g->targetondeck = 0;

    /* non-matching non-NULL phrases indicate
     * a new phrase */
    shouldiwait =
        s->phrase != NULL &&
        s->phrase != g->phrase_selected;

    if (shouldiwait) {
        g->please_wait = 1;
        return 1.0;
    }

    g->num = s->num;
    g->den = s->den;
    set_curtarget(g, s->target);

    set_curnode(g, s->node);
    g->phrase_selected = s->phrase;

    init_state(&g->nxtstate);

    if (g->curnode != NULL) {
        find_next_node(g, g->curnode, &g->nxtstate);
    }

    g->nxttarget = g->nxtstate.target;

    if (g->nxttarget != NULL) {
        g->nxtval = g->nxttarget->value;
    } else {
        g->nxtval = g->curval;
    }
}
#+END_SRC

What triggers =targetondeck=? Usually this happens when the
internal ramp reaches the end. This can also be triggered
during the beat check-in, when a conductor signal demands
to jump to the next phrase before fully finishing the
current one.
** Updating the phase using modifier and friends
To begin, the modifier amount is calculated.

The modifier and increment amount are used together to
update the existing phase.

#+NAME: update_phase
#+BEGIN_SRC c
{
SKFLT i;
i = inc * ((SKFLT)g->num / g->den);
phs += i;
}
#+END_SRC

The phase is then checked to see if it has exceeded 1.
If it has, a change in nodes is required.

#+NAME: check_and_update
#+BEGIN_SRC c
if (phs > 1.0) {
    <<goto_next_node>>
    <<wraparound>>
}
#+END_SRC
** Signalling to go to the next target
When the ramp reaches the end, it is time to go on to the
next node with a target. By the time it reaches this point,
this node has already been found, and just needs to be
signalled to switch with the variable =targetondeck=.

#+NAME: goto_next_node
#+BEGIN_SRC c
g->targetondeck = 1;
#+END_SRC
** Finding the next node in the Ramp Tree
When a new node begins, the next with a target
in the ramp tree must be found immediately after.
Many programs using Gest require knowing the next target.

The next node is found by traversing the Ramp
Tree based on the position the current node is in.

The process of finding the next node is done in a function
called =find_next_node=. It will find the next node, and
store the results in an instance of =gest_state=. The
=top= node is expected to be the currently selected node
=curnode=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void find_next_node(gest_d *g,
                           gest_node *top,
                           gest_state *state);
#+END_SRC

Traversal starts large and gets smaller.

To begin, check and see if the next node happens to be in
the next phrase. That would mean the currently selected
node is the right-most node (no nodes after it)
in the top of the tree. If this is true, it is time to
*wait* for the next phrase on the next down beat. If the
next phrase is being found here, it has arrived a tad too
early (which is actually better than being a
tad too late, as it turns out. It's one or the other here).

If it's not the top of the tree, there is a general check
to see if the current node is the right-most node relative
to the position in the tree. If so, the node reverts the
global modification it did, and goes up one level to the
parent node to check the next node there.

Finally, the next node is found, and the program recursively
dives into it to find the next target, applying modifiers
along the way. Before that happens, the current node *may*
need to revert the global modifier if it is a monoramp
with a modifier greater than 1.

If the next node happens to be a monoramp with a modifier
greater than 1, it will also apply modifications. But should
be handled inside of =dive_to_target=. If the node is already
a target with a monoramp >1, this gets applied here as a
special exception.

#+NAME: funcs
#+BEGIN_SRC c
static void find_next_node(gest_d *g,
                           gest_node *top,
                           gest_state *state)
{
    gest_node *next;
    gest_node *last_reverted;
    gest_phrase *phrase;
    int num, den;

    next = NULL;
    last_reverted = NULL;

    num = g->num;
    den = g->den;
    phrase = g->phrase_selected;

    while (next == NULL) {
        if (top == g->phrase_selected->top) {
            /* are we at the end */
            /* if so, go to next phrase */
            if (top->next == NULL) {
                /* next node is in next phrase */
                phrase = phrase->next;
                if (phrase != NULL) next = phrase->top;
                else next = NULL;
                g->num = 1;
                g->den = 1;
                if (next != NULL) {
                   next = dive_to_target(g, next);
                }
                break;
            } else {
                /* go to next child in top polyramp node */
                next = top->next;

                if (next->target == NULL) {
                    next = dive_to_target(g, next);
                }
            }
        } else if (top->next == NULL) {
            revert_modifier(g, top->parent);
            last_reverted = top->parent;
            top = top->parent;
        } else {
            next = top->next;

            /* if top is a monoramp >1, revert it */

            if (top != last_reverted) {
                if (top->type == NODE_MONORAMP && top->modifier > 1) {
                    /* revert the monoramp */
                    revert_modifier(g, top);
                }
            }

            /* dive_to_target applies modifiers */
            /* continguous nodes on the same level don't have these */
            if (next->target == NULL) {
                next = dive_to_target(g, next);
            } else if (next->type == NODE_MONORAMP && next->modifier > 1) {
                /* next node is on same level but is monoramp */
                apply_modifier(g, next);
            }

        }
    }


    state->num = g->num;
    state->den = g->den;
    state->node = next;
    state->target = node_target(next);
    state->phrase = phrase;

    /* restore old numerator and denominator */

    g->num = num;
    g->den = den;
}
#+END_SRC
** When a phrase is over, wraparound
A phrase is considered over when it reaches the end of the
top-level polyramp. At this point, the next phrase is found
and set to be the beginning of that node.

All ramps begin exactly at 0. When wraparound happens,
the roundoff error is stored in the error variable.

#+NAME: wraparound
#+BEGIN_SRC c
while (phs > 1) phs--;
phs = 0;
#+END_SRC
** Handling Roundoff Error in Phrases
Roundoff error is a natural part of working with floating
point, and difficult to avoid entirely. Roundoff error
in this context leads to temporal drift in the timing
signal. Unchecked, this will eventually lead to phrases
being completly out of step with the rest of the music
surrounding it.

Chunking gestures into phrases helps thwart some of the
major drift buildup that can occur over time. Phrases
ensure that any drift is localized, which, if the phrases
are small enough, should be quite negligible for most
musical purposes.

The Ramp Tree in a phrase applies many manipulations to a
phasor signal, and this can cause phrases to either finish
too quickly or too slowly. If choosing one or the other,
finishing too quickly is always the preference.

If a phrase ends before the conductor does, it is told to
wait. While waiting, it will only return 1 without updating
any state. When the conductor finally does catch up, the
phrase will be granted permission to move on to the next
phrase.

Every time the phasor in a conductor signal resets (wraps
back), it registered as a new beat. This beat gives gest
an opportunity to "check in" with itself. Is it going ahead
of schedule? Behind? And then, try to make the appropriate
corrections.

The progress of a phrase is kept inside of a monoramp that
spans the duration of the phrase, and the beat position is
kept track of as a sort of counter. A new beat indicates the
ideal time position, which can be compared against the the
actual position in the progress monoramp.

Dividing the ideal position and actual position gives us
a correction factor that slightly speeds up or slows down
the phasor within the beat. If the ideal is a bit farther
along, the correction factor will be a value greater than 1
that runs to catch up. If the ideal is a bit behind, the
factor will be less than 1, and will hold things back until
the next beat.

With any luck, the phrase will end just slightly before
the conductor, allowing it to wait for the next signal.
This happens when the monoramp exceeds 1 and/or the ramp
tree hits the end of the phrase. At any rate, a flag is set.

There can also be cases where the phrase is too slow.
Hopefully, it is fast enough to be wrapping up the last
target in the ramp tree. This is detected when a beat
happens that is past the duration of the phrase. When
this happens, the phrase is reset early, and caution
is scattered to the wind. It's not an ideal situation, as
this has the potential to create an audible glitch in the
gesture.
* Memory Collections
Memory-allocated things are managed in a data type known
as a =collection=. Data allocated in a collection can be
then used on things like targets, ramp trees, phrases, and
extra things needed by behaviors.
** Struct Declarations
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_collection gest_collection;
#+END_SRC

A collection is a linked list of generic pointers.

#+NAME: struct_collection
#+BEGIN_SRC c
<<struct_collection_entry>>
struct gest_collection {
    struct gest_entry *tail;
    int nitems;
};
#+END_SRC

A linked list entry contains a generic pointer
and an optional destructor callback that can free
any additional memory allocated and bound to the
pointer by the user.

#+NAME: struct_collection_entry
#+BEGIN_SRC c
struct gest_entry {
    void *ptr;
    void (*free)(void *);
    struct gest_entry *prev;
};
#+END_SRC
** Initialization
The collection is initialized with =collection_init=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void collection_init(gest_collection *col);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void collection_init(gest_collection *col)
{
    col->tail = NULL;
    col->nitems = 0;
}
#+END_SRC
** Allocating Memory
Anytime Gest needs to allocate memory, the gesture
system uses an instance of the allocator.
*** Allocation with Destructor Callback
The core function for memory allocation is
=collection_alloc_dtor=. In addition to providing the size,
an a user-defined destructor callback function. Note that
the allocated memory here is already being managed, and that
this is only used for any additional memory allocated inside
of it.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void * collection_alloc_dtor(gest_collection *col,
                                    size_t sz,
                                    void (*free)(void*));
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void * collection_alloc_dtor(gest_collection *col,
                                    size_t sz,
                                    void (*free)(void*))
{
    struct gest_entry *ent;

    ent = malloc(sizeof(struct gest_entry));

    ent->ptr = calloc(1, sz);
    ent->free = free;

    ent->prev = col->tail;
    col->tail = ent;
    col->nitems++;

    return ent->ptr;
}
#+END_SRC
*** Memory allocation only
Much of the time the destructor is not needed, so a more
convenient =collection_alloc= function is provided.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void * collection_alloc(gest_collection *col, size_t sz);
#+END_SRC

Creates a new entry, allocates a void pointer, appends the
entry to the list, then returns the pointer.

#+NAME: funcs
#+BEGIN_SRC c
static void * collection_alloc(gest_collection *col, size_t sz)
{
    return collection_alloc_dtor(col, sz, NULL);
}
#+END_SRC
*** Gesture Allocator Helper functions
The static function =gest_alloc= is a helper function
which mostly exists to make code look cleaner.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void * gest_alloc(gest_d *gest, size_t sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void * gest_alloc(gest_d *gest, size_t sz)
{
    return collection_alloc(&gest->col, sz);
}
#+END_SRC

** Freeing The Collection
All previously allocated memory in Gest can be freed with
the function =collection_cleanup=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void collection_cleanup(gest_collection *col);
#+END_SRC

Iterate through the linked list and free it all.

Note that the linked list moves backwards from
the tail to the head so that the most recently allocated
stuff gets freed first. This is done to minimize situations
where allocated items are somehow required to exist before
being freed.

#+NAME: funcs
#+BEGIN_SRC c
static void collection_cleanup(gest_collection *col)
{
    int n;
    struct gest_entry *ent, *prev;

    ent = col->tail;

    for (n = 0; n < col->nitems; n++) {
        prev = ent->prev;
        if (ent->free != NULL) ent->free(ent->ptr);
        free(ent->ptr);
        free(ent);
        ent = prev;
    }
}
#+END_SRC
* Targets
Targets can be contained inside of a node. If the tree
reaches a node with a target, it sets it to be that target
when the node starts.
** Struct Declaration
A target in gest is known as a =gest_target=

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_target gest_target;
#+END_SRC

A target stores 3 main things: a scalar value, a callback, and
some user data. The callback is a function that takes 4
arguments, the gest struct, the internal value, the
position, the next value,
and user data. It returns a floating point value.

Targets need to managed in their own linked list, in
addition to being referenced in the node they belong to.
Targets need to know what target is coming next (if there
is one coming next).

#+NAME: gest_target
#+BEGIN_SRC c
struct gest_target {
    SKFLT value;
    SKFLT (*tick)(gest_d *, SKFLT, void *);
    void *aux; /* aux data for behavior function */
    SKFLT (*mix)(gest_d *, SKFLT, SKFLT, SKFLT);
    void *ud; /* user data attached to this target */
    gest_target *next;
    gest_target* (*get)(gest_node *n, gest_target *t);
    gest_metatarget *meta;
    <<temporal_weight>>
};
#+END_SRC
** Initialization
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_target_init(gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_target_init(gest_target *t)
{
    t->value = 0;
    t->tick = NULL;
    t->ud = NULL;
    t->aux = NULL;
    t->next = NULL;
    t->mix = default_mix;
    t->get = NULL;
    t->meta = NULL;
    <<init_temporal_weight>>
}
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static SKFLT default_mix(gest_d *g, SKFLT x, SKFLT y, SKFLT a);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static SKFLT default_mix(gest_d *g, SKFLT x, SKFLT y, SKFLT a)
{
    return (1 - a)*x + a*y;
}
#+END_SRC
** Binding Targets to Ramp Tree Nodes
Every target created is bound to exactly one node in a ramp
tree. Such a binding indicates a terminal leaf node in the
tree.

Creating targets are an important operation because
it is the thing that moves the tree forward (from left
to right) in population.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_target * mktarget(gest_d *g);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_target * mktarget(gest_d *g)
{
    gest_target *t;
    gest_node *last;
    gest_node *curnode;

    t = NULL;
    last = NULL;
    curnode = g->curnode;

    <<create_target>>

    if (g->mtpos > 0) {
        <<tie_to_metatarget>>
        return t;
    }

    if (curnode == NULL) {
        return NULL;
    }

    <<check_current_node>>
    <<tie_to_node>>
    <<move_forward>>

    return t;
}
#+END_SRC

Data for a new target is allocated and initialized. What
to do with the target remains to be seen.

#+NAME: create_target
#+BEGIN_SRC c
t = gest_alloc(g, sizeof(gest_target));
gest_target_init(t);
#+END_SRC


A check is done to see if the current node can have
a target applied in the first place.

#+NAME: check_current_node
#+BEGIN_SRC c
{
    int size;

    size = node_count(curnode, &last);

    if (curnode != NULL && size >= curnode->modifier) {
        return NULL;
    }
}
#+END_SRC

Technically, a target is bound to the last created node,
which is always a monoramp.
But these
monoramps don't have to be explicitely created. Example:
"polyramp(3), target, target, target" will create a polyramp
node with 3 divisions and populate each one of those
divisisons (a monoramp) with a target (called one after
another 3 times). So, how to deal with that? By checking
the type of the last created child. If it exists at all,
it is always going to be a monoramp and never a polyramp,
due to the left-to-right method of population (new
polyramps always get selected to be the active node).
A monoramp's target can be checked if it is occupied. A new
target is bound to an unoccupied monoramp target. Otherwise,
a new monoramp with a modifier of 1 is created to house
the new target.

#+NAME: tie_to_node
#+BEGIN_SRC c
{
    int rc;

    rc = last != NULL &&
        last->type == NODE_MONORAMP &&
        last->target == NULL &&
        last->nchildren == 0;

    if (rc) {
        last->target = t;
    } else {
        rc = curnode->type == NODE_MONORAMP &&
            curnode->target == NULL;

        if (rc) {
            curnode->target = t;
        } else {
            gest_node *mr;
            mr = mkmonoramp(g, curnode, 1);
            mr->target = t;
        }
    }
}
#+END_SRC

Targets are the things that move the ramp tree forward in a
left-to-right fashion when it is being populated.

A movement to the next available node happens when the
current node has been filled up. When this happens, it will
attempt to move up a level to find free slots there. This
will continue to happen until a free slot is found, or it
reaches the end of the phrase.

#+NAME: move_forward
#+BEGIN_SRC c
{
    gest_node *next;
    gest_node *curr;

    next = NULL;
    curr = curnode;

    while (next == NULL) {
        int size;
        gest_node *last;
        int limit;

        /* is there any room in the current node? */

        size = node_count(curr, &last);

        if (curr->type == NODE_MONORAMP) {
            limit = curr->nchildren;
        } else {
            limit = curr->modifier;
        }

        /* no room ... */
        if (size >= limit) {
            /* onto the next... */

            /* we've reached the top */
            if (curr == curr->parent) break;

            /* try one level up */

            curr = curr->parent;

        } else {
            /* this node has room! */
            next = curr;
        }
    }

    set_curnode(g, next);
}
#+END_SRC

If there is a metatarget being active populated, the target
will be sent there instead of being tied to a node. The most
recent metatarget in play is retrieved via the metatarget
stack, and a target is appeneded. If it has reached the end,
the metatarget itself is popped off the stack here.

#+NAME: tie_to_metatarget
#+BEGIN_SRC c
gest_metatarget *mt;

/* get from top of stack */
mt = g->mtstack[g->mtpos - 1];

/* append to targets array */
mt->targets[mt->pos++] = t;

/* pop off stack if reached the end */
if (mt->pos >= mt->size) {
    g->mtpos--;
    g->mtstack[g->mtpos] = NULL;
    mt->pos = 0;
}
#+END_SRC
** Temporal Weight
Targets have temporal mass and inertia. These values
can be used to slow down or speed up the global tempo in
the conductor signal generator. Mass is the amount used to
speed up or slowdown the tempo. Inertia is the speed at
which it changes.

#+NAME: temporal_weight
#+BEGIN_SRC c
SKFLT mass;
SKFLT inertia;
#+END_SRC

By default, they are set to have instantaneous mass
and weight.

#+NAME: init_temporal_weight
#+BEGIN_SRC c
t->mass = 0;
t->inertia = 0;
#+END_SRC

Inertial values are in units of seconds. Positive values
only. Will be clamped.

Temporal weight values can either be relative or absolute,
determined by a flag. They are in range -120 to 120. 120 is
used for its highly divisble properites.

Masses and inertial values can mean different things, such
as relative or absolute increases. They can
also be ignored entirely. This is indicated by the
mode flags =mass_mode= and =inertia_mode=.

#+NAME: temporal_weight
#+BEGIN_SRC c
int mass_mode;
int inertia_mode;
#+END_SRC

#+NAME: enums
#+BEGIN_SRC c
enum {
    WEIGHT_IGNORE,
    WEIGHT_ABSOLUTE,
    WEIGHT_RELATIVE
};
#+END_SRC

By default, both mass and inertia are set to be ignored.

#+NAME: init_temporal_weight
#+BEGIN_SRC c
t->mass_mode = WEIGHT_IGNORE;
t->inertia_mode = WEIGHT_IGNORE;
#+END_SRC

Temporal weight can be applied globally using the local
function =apply_weight=. If the value is of type
=WEIGHT_ABSOLUTE=, it will set the value directly. If
it is =WEIGHT_RELATIVE=, it will treat the incoming
value as a percentage and add it accordingly.

values set to be =WEIGHT_IGNORE= will be ignored entirely.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void apply_weight(gest_d *g, gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void update_weightval(SKFLT val, int flag, SKFLT *out)
{
    if (flag == WEIGHT_ABSOLUTE) {
        *out = val;
    } else if (flag == WEIGHT_RELATIVE) {
        *out += (*out) * val;
    }
}

static void apply_weight(gest_d *g, gest_target *t)
{
    update_weightval(t->mass, t->mass_mode, &g->mass);
    update_weightval(t->inertia, t->inertia_mode, &g->inertia);
}
#+END_SRC
** Set Mix Callback
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_target_mix(gest_target *t,
                     SKFLT (*mix)(gest_d *, SKFLT, SKFLT, SKFLT));
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_target_mix(gest_target *t,
                     SKFLT (*mix)(gest_d *, SKFLT, SKFLT, SKFLT))
{
    t->mix = mix;
}
#+END_SRC
** Set/get user data
#+NAME: funcdefs
#+BEGIN_SRC c
void gest_target_data_set(gest_target *t, void *ud);
void* gest_target_data_get(gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gest_target_data_set(gest_target *t, void *ud)
{
    t->ud = ud;
}

void* gest_target_data_get(gest_target *t)
{
    return t->ud;
}
#+END_SRC
* Computation
Gest is synthesized with =gest_tick=. It expects
a conductor phasor signal =conductor=.

#+NAME: funcdefs
#+BEGIN_SRC c
SKFLT gest_tick(gest_d *g, SKFLT conductor);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
SKFLT gest_tick(gest_d *g, SKFLT conductor)
{
    SKFLT out;
    SKFLT inc;
    int reset;

    out = 0;

    <<ignore_negative_values>>
    <<analysis>>
    <<compute_ramptree>>
    <<apply_targets>>
    <<update_previous_value>>

    g->prevout = out;
    return out;
}
#+END_SRC

Negative values in the conductor hold no meaning, so if one
pops up, gesture computation is ignored and the previously
cached output value is returned, effectively "pausing" gest.
This feature was added more recently so that gest could
work well with a sndkit algorithm called =clkphs=, which
converts a clock signal into a gest-compatible phasor
signal. clkphs requires some initial time in the beginning
to compute the first period of the phasor, and during that
time it returns -1.

#+NAME: ignore_negative_values
#+BEGIN_SRC c
if (conductor < 0) return g->prevout;
#+END_SRC

Analysis. The conductor signal is analyzed, and used to
drive the timing in the Ramp Tree. The previous conductor
signal is subtracted from the current one to produce
the phasor increment amount =inc=.

A phase reset is detected if the current conductor value
is less than the previous. A reset flag is set, and
the sign of the increment value is flipped to be positive.

For reasons I don't understand at the moment, it seems
that the first reset found at initialization needs to be
discounted, so there is logic built in here to handle that.

#+NAME: analysis
#+BEGIN_SRC c
inc = conductor - g->last;
reset = 0;

if (conductor < g->last) {
    inc = g->last_inc;
    reset = 1;
}

g->last_inc = inc;

/* discount reset found at initial sample */
if (g->phs == -1) {
    g->phs = 0;
    reset = 0;
}

g->last = conductor;
#+END_SRC

Conductor analysis components, the ramp tree can then be
computed with =ramptree_step=, which updates the state of
the tree and returns the tramptree value.

#+NAME: compute_ramptree
#+BEGIN_SRC c
out = ramptree_step(g, inc, reset);
#+END_SRC

With the computed ramp tree value in hand, the current
target's tick function can be called. This function returns
the output gesture.

#+NAME: apply_targets
#+BEGIN_SRC c
if (g->curtarget != NULL) {
    out = g->curtarget->tick(g, out, g->curtarget->aux);
    out = g->curtarget->mix(g, g->curval, g->nxtval, out);
}
#+END_SRC

Right before the value is returned, the current output
is cached in the =prevout= variable.

#+NAME: update_previous_value
#+BEGIN_SRC c
g->prevout = out;
#+END_SRC
* Metatargets
Metatargets will probably end up in
a larger category of meta-things, including metaramps
and metabehaviors. But metatargets come first.
** Overview
A metatarget is a target containing one or more
targets inside of itself. Whenever it gets selected
it can choose one of these targets. In other words,
this allows a particular target to dynamically
change every time the phrase it is contained in is played.

When metatargets are created, the number of
targets must be known ahead of time. Targets
created after the metatarget get automatically
appended to the metatarget until there is no
more room left.
** Struct Declaration
A metatarget is a special struct stored inside
of a target inside via user-data pointer provided.
It contains an array of target pointers, the size,
and variable storing the current position.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct gest_metatarget gest_metatarget;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
struct gest_metatarget {
    int pos;
    int size;
    gest_target **targets;
};
#+END_SRC

By default, a metatarget will choose targets in sequence.
This is done by overriding the default "get" callback
in the target.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_target *get_seq(gest_node *n, gest_target *t);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_target *get_seq(gest_node *n, gest_target *t)
{
    gest_metatarget *mt;

    mt = t->meta;

    if (mt->pos >= mt->size) mt->pos = 0;

    return mt->targets[mt->pos++];
}
#+END_SRC
** Metatarget Allocation
A metatarget is allocated with the function
=metatarget_alloc=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static gest_metatarget * metatarget_alloc(gest_d *g, int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static gest_metatarget * metatarget_alloc(gest_d *g, int sz)
{
    gest_metatarget *mt;
    int t;

    mt = gest_alloc(g, sizeof(gest_metatarget));
    mt->size = sz;
    mt->pos = 0;
    mt->targets = gest_alloc(g, sizeof(gest_target) * sz);

    for (t = 0; t < sz; t++) {
        mt->targets[t] = NULL;
    }

    return mt;
}
#+END_SRC
** Metatarget Population
Metatarget population in Gest works by caching the
metatarget inside of the Gest struct. When a metatarget
is first created, it is set to be that value and
the position is set to be 0. Every time a target is added,
it will append to a metatarget instead of binding to a
phrase and increment the position. When the position reaches
the limit, the metatarget cache value is emptied.

Nested metatargets will need to use what will be
a fixed-size metatarget stack.
When a value is emptied, it is also popped from the stack.

A depth of 4 for
now will be used. If I need it to go deeper than that,
it will be changed.

#+NAME: gest_d
#+BEGIN_SRC c
#define GEST_MTSTACK_SIZE 4
gest_metatarget *mtstack[GEST_MTSTACK_SIZE];
int mtpos;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
{
    int i;

    for (i = 0; i < GEST_MTSTACK_SIZE; i++) {
        g->mtstack[i] = NULL;
    }

    g->mtpos = 0;
}
#+END_SRC

See =gest_addmetatarget= function for more usage
on this stack.
